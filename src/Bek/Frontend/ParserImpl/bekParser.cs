//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 bek.g 2015-10-10 14:21:25

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 168, 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591

 
using Microsoft.Bek.Frontend.AST; 
using System.Collections.Generic;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;

namespace Microsoft.Bek.Frontend.ParserImpl
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
[System.CLSCompliant(false)]
public partial class bekParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "BIG_UNICODE_ESC", "CHAR", "COMMENT", "ESC_SEQ", "HEX_DIGIT", "HEX_SEQ", "ID", "INFIX_ARITHM_OP", "INT", "LSTRING", "OCTAL_ESC", "STRING", "UNARY_OP", "UNICODE_ESC", "WS", "'&&'", "'('", "')'", "'*'", "'+'", "','", "':'", "':='", "';'", "'='", "'==>'", "'['", "']'", "'case'", "'else'", "'end'", "'false'", "'function'", "'if'", "'in'", "'iter'", "'program'", "'raise'", "'replace'", "'return'", "'skip'", "'true'", "'yield'", "'{'", "'||'", "'}'"
	};
	public const int EOF=-1;
	public const int BIG_UNICODE_ESC=4;
	public const int CHAR=5;
	public const int COMMENT=6;
	public const int ESC_SEQ=7;
	public const int HEX_DIGIT=8;
	public const int HEX_SEQ=9;
	public const int ID=10;
	public const int INFIX_ARITHM_OP=11;
	public const int INT=12;
	public const int LSTRING=13;
	public const int OCTAL_ESC=14;
	public const int STRING=15;
	public const int UNARY_OP=16;
	public const int UNICODE_ESC=17;
	public const int WS=18;
	public const int T__19=19;
	public const int T__20=20;
	public const int T__21=21;
	public const int T__22=22;
	public const int T__23=23;
	public const int T__24=24;
	public const int T__25=25;
	public const int T__26=26;
	public const int T__27=27;
	public const int T__28=28;
	public const int T__29=29;
	public const int T__30=30;
	public const int T__31=31;
	public const int T__32=32;
	public const int T__33=33;
	public const int T__34=34;
	public const int T__35=35;
	public const int T__36=36;
	public const int T__37=37;
	public const int T__38=38;
	public const int T__39=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;
	public const int T__48=48;
	public const int T__49=49;

	#if ANTLR_DEBUG
		private static readonly bool[] decisionCanBacktrack =
			new bool[]
			{
				false, // invalid decision
				false, false, false, false, false, false, false, false, false, true, 
				false, false, false, false, false, false, false, false, false, false, 
				false, true, false, false, false, false, false, false, false, false, 
				false, false, false, false, false, 
			};
	#else
		private static readonly bool[] decisionCanBacktrack = new bool[0];
	#endif
	public bekParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public bekParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		this.state.ruleMemo = new System.Collections.Generic.Dictionary<int, int>[75+1];


		OnCreated();
	}

	public override string[] TokenNames { get { return bekParser.tokenNames; } }
	public override string GrammarFileName { get { return "bek.g"; } }


	protected override object RecoverFromMismatchedToken(IIntStream input, int ttype, BitSet follow)
	{
	    // just rethrow  
	    throw new MismatchedTokenException(ttype, input);
	}

	public override object RecoverFromMismatchedSet(IIntStream input, RecognitionException e, BitSet follow)
	{
	    // rethrow...
	    throw e; 
	}

	internal List<BekPgm> BekPgms() { return bekPgms(); }

	internal expr Comp_expr() { return comp_expr(); }



	[Conditional("ANTLR_TRACE")]
	protected virtual void OnCreated() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}

	#region Rules

	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_bekPgms() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_bekPgms() {}
	// $ANTLR start "bekPgms"
	// bek.g:52:1: bekPgms returns [List<BekPgm> result] : funcs= bekLocalFunctions ( bekPgm )+ EOF ;
	[GrammarRule("bekPgms")]
	private List<BekPgm> bekPgms()
	{
		EnterRule_bekPgms();
		EnterRule("bekPgms", 1);
		TraceIn("bekPgms", 1);
	    List<BekPgm> result = default(List<BekPgm>);

	    int bekPgms_StartIndex = input.Index;

	    List<BekLocalFunction> funcs = default(List<BekLocalFunction>);
	    BekPgm bekPgm1 = default(BekPgm);

	     result = new List<BekPgm>(); 
		try { DebugEnterRule(GrammarFileName, "bekPgms");
		DebugLocation(52, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 1)) { return result; }

			// bek.g:54:5: (funcs= bekLocalFunctions ( bekPgm )+ EOF )
			DebugEnterAlt(1);
			// bek.g:54:7: funcs= bekLocalFunctions ( bekPgm )+ EOF
			{
			DebugLocation(54, 12);
			PushFollow(Follow._bekLocalFunctions_in_bekPgms111);
			funcs=bekLocalFunctions();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(55, 4);
			// bek.g:55:4: ( bekPgm )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, decisionCanBacktrack[1]);
				int LA1_1 = input.LA(1);

				if ((LA1_1==40))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// bek.g:55:5: bekPgm
					{
					DebugLocation(55, 5);
					PushFollow(Follow._bekPgm_in_bekPgms118);
					bekPgm1=bekPgm();
					PopFollow();
					if (state.failed) return result;
					DebugLocation(55, 12);
					if (state.backtracking == 0)
					{
						 bekPgm1.AddLocalFunctions(funcs); result.Add(bekPgm1); 
					}

					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					if (state.backtracking>0) {state.failed=true; return result;}
					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(56, 7);
			Match(input,EOF,Follow._EOF_in_bekPgms131); if (state.failed) return result;

			}

		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("bekPgms", 1);
			LeaveRule("bekPgms", 1);
			LeaveRule_bekPgms();
	        if (state.backtracking > 0) { Memoize(input, 1, bekPgms_StartIndex); }

	    }
	 	DebugLocation(57, 4);
		} finally { DebugExitRule(GrammarFileName, "bekPgms"); }
		return result;

	}
	// $ANTLR end "bekPgms"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_bekPgm() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_bekPgm() {}
	// $ANTLR start "bekPgm"
	// bek.g:60:1: bekPgm returns [BekPgm result] : 'program' name= ID '(' str= ID ')' '{' body= statement '}' ;
	[GrammarRule("bekPgm")]
	private BekPgm bekPgm()
	{
		EnterRule_bekPgm();
		EnterRule("bekPgm", 2);
		TraceIn("bekPgm", 2);
	    BekPgm result = default(BekPgm);

	    int bekPgm_StartIndex = input.Index;

	    IToken name = default(IToken);
	    IToken str = default(IToken);
	    stmt body = default(stmt);

		try { DebugEnterRule(GrammarFileName, "bekPgm");
		DebugLocation(60, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 2)) { return result; }

			// bek.g:61:2: ( 'program' name= ID '(' str= ID ')' '{' body= statement '}' )
			DebugEnterAlt(1);
			// bek.g:61:4: 'program' name= ID '(' str= ID ')' '{' body= statement '}'
			{
			DebugLocation(61, 4);
			Match(input,40,Follow._40_in_bekPgm150); if (state.failed) return result;
			DebugLocation(61, 18);
			name=(IToken)Match(input,ID,Follow._ID_in_bekPgm154); if (state.failed) return result;
			DebugLocation(61, 22);
			Match(input,20,Follow._20_in_bekPgm156); if (state.failed) return result;
			DebugLocation(61, 29);
			str=(IToken)Match(input,ID,Follow._ID_in_bekPgm160); if (state.failed) return result;
			DebugLocation(61, 33);
			Match(input,21,Follow._21_in_bekPgm162); if (state.failed) return result;
			DebugLocation(61, 37);
			Match(input,47,Follow._47_in_bekPgm164); if (state.failed) return result;
			DebugLocation(61, 45);
			PushFollow(Follow._statement_in_bekPgm168);
			body=statement();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(61, 56);
			Match(input,49,Follow._49_in_bekPgm170); if (state.failed) return result;
			DebugLocation(62, 5);
			if (state.backtracking == 0)
			{
				  result = new BekPgm(new ident(name.Text, name.Line, name.CharPositionInLine), new ident(str.Text, str.Line, str.CharPositionInLine), body);
				    
			}

			}

		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("bekPgm", 2);
			LeaveRule("bekPgm", 2);
			LeaveRule_bekPgm();
	        if (state.backtracking > 0) { Memoize(input, 2, bekPgm_StartIndex); }

	    }
	 	DebugLocation(64, 1);
		} finally { DebugExitRule(GrammarFileName, "bekPgm"); }
		return result;

	}
	// $ANTLR end "bekPgm"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_bekLocalFunctions() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_bekLocalFunctions() {}
	// $ANTLR start "bekLocalFunctions"
	// bek.g:66:1: bekLocalFunctions returns [List<BekLocalFunction> result] : ( 'function' fname= ID '(' args= ident_list ')' '=' body= comp_expr ';' )* ;
	[GrammarRule("bekLocalFunctions")]
	private List<BekLocalFunction> bekLocalFunctions()
	{
		EnterRule_bekLocalFunctions();
		EnterRule("bekLocalFunctions", 3);
		TraceIn("bekLocalFunctions", 3);
	    List<BekLocalFunction> result = default(List<BekLocalFunction>);

	    int bekLocalFunctions_StartIndex = input.Index;

	    IToken fname = default(IToken);
	    List<ident> args = default(List<ident>);
	    expr body = default(expr);

	     result = new List<BekLocalFunction>(); 
		try { DebugEnterRule(GrammarFileName, "bekLocalFunctions");
		DebugLocation(66, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 3)) { return result; }

			// bek.g:68:2: ( ( 'function' fname= ID '(' args= ident_list ')' '=' body= comp_expr ';' )* )
			DebugEnterAlt(1);
			// bek.g:68:4: ( 'function' fname= ID '(' args= ident_list ')' '=' body= comp_expr ';' )*
			{
			DebugLocation(68, 4);
			// bek.g:68:4: ( 'function' fname= ID '(' args= ident_list ')' '=' body= comp_expr ';' )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, decisionCanBacktrack[2]);
				int LA2_1 = input.LA(1);

				if ((LA2_1==36))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// bek.g:68:5: 'function' fname= ID '(' args= ident_list ')' '=' body= comp_expr ';'
					{
					DebugLocation(68, 5);
					Match(input,36,Follow._36_in_bekLocalFunctions202); if (state.failed) return result;
					DebugLocation(68, 21);
					fname=(IToken)Match(input,ID,Follow._ID_in_bekLocalFunctions206); if (state.failed) return result;
					DebugLocation(68, 25);
					Match(input,20,Follow._20_in_bekLocalFunctions208); if (state.failed) return result;
					DebugLocation(68, 33);
					PushFollow(Follow._ident_list_in_bekLocalFunctions212);
					args=ident_list();
					PopFollow();
					if (state.failed) return result;
					DebugLocation(68, 45);
					Match(input,21,Follow._21_in_bekLocalFunctions214); if (state.failed) return result;
					DebugLocation(68, 49);
					Match(input,28,Follow._28_in_bekLocalFunctions216); if (state.failed) return result;
					DebugLocation(68, 57);
					PushFollow(Follow._comp_expr_in_bekLocalFunctions220);
					body=comp_expr();
					PopFollow();
					if (state.failed) return result;
					DebugLocation(68, 68);
					Match(input,27,Follow._27_in_bekLocalFunctions222); if (state.failed) return result;
					DebugLocation(69, 6);
					if (state.backtracking == 0)
					{
						 if (result.Find(x => x.id.name.Equals(fname.Text)) != null) 
								  throw new Microsoft.Bek.Frontend.Meta.BekParseException(fname.Line, fname.CharPositionInLine, string.Format("'{0}' duplicate definition", fname.Text));
								  result.Add(new BekLocalFunction(new ident(fname.Text, fname.Line, fname.CharPositionInLine), args.ToArray(), body)); 
					}

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("bekLocalFunctions", 3);
			LeaveRule("bekLocalFunctions", 3);
			LeaveRule_bekLocalFunctions();
	        if (state.backtracking > 0) { Memoize(input, 3, bekLocalFunctions_StartIndex); }

	    }
	 	DebugLocation(72, 1);
		} finally { DebugExitRule(GrammarFileName, "bekLocalFunctions"); }
		return result;

	}
	// $ANTLR end "bekLocalFunctions"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_ident_list() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_ident_list() {}
	// $ANTLR start "ident_list"
	// bek.g:74:1: ident_list returns [List<ident> result] : (arg= ID ( ',' arg1= ID )* )? ;
	[GrammarRule("ident_list")]
	private List<ident> ident_list()
	{
		EnterRule_ident_list();
		EnterRule("ident_list", 4);
		TraceIn("ident_list", 4);
	    List<ident> result = default(List<ident>);

	    int ident_list_StartIndex = input.Index;

	    IToken arg = default(IToken);
	    IToken arg1 = default(IToken);

	     result = new List<ident>(); 
		try { DebugEnterRule(GrammarFileName, "ident_list");
		DebugLocation(74, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 4)) { return result; }

			// bek.g:76:2: ( (arg= ID ( ',' arg1= ID )* )? )
			DebugEnterAlt(1);
			// bek.g:76:4: (arg= ID ( ',' arg1= ID )* )?
			{
			DebugLocation(76, 4);
			// bek.g:76:4: (arg= ID ( ',' arg1= ID )* )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, decisionCanBacktrack[4]);
			int LA4_1 = input.LA(1);

			if ((LA4_1==ID))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// bek.g:76:5: arg= ID ( ',' arg1= ID )*
				{
				DebugLocation(76, 8);
				arg=(IToken)Match(input,ID,Follow._ID_in_ident_list259); if (state.failed) return result;
				DebugLocation(76, 12);
				if (state.backtracking == 0)
				{
					 result.Add(new ident(arg.Text, arg.Line, arg.CharPositionInLine)); 
				}
				DebugLocation(77, 7);
				// bek.g:77:7: ( ',' arg1= ID )*
				try { DebugEnterSubRule(3);
				while (true)
				{
					int alt3=2;
					try { DebugEnterDecision(3, decisionCanBacktrack[3]);
					int LA3_1 = input.LA(1);

					if ((LA3_1==24))
					{
						alt3 = 1;
					}


					} finally { DebugExitDecision(3); }
					switch ( alt3 )
					{
					case 1:
						DebugEnterAlt(1);
						// bek.g:77:8: ',' arg1= ID
						{
						DebugLocation(77, 8);
						Match(input,24,Follow._24_in_ident_list271); if (state.failed) return result;
						DebugLocation(77, 16);
						arg1=(IToken)Match(input,ID,Follow._ID_in_ident_list275); if (state.failed) return result;
						DebugLocation(78, 7);
						if (state.backtracking == 0)
						{
							 if (result.Find(x => x.name.Equals(arg1.Text)) != null) 
									throw new Microsoft.Bek.Frontend.Meta.BekParseException(arg1.Line, arg1.CharPositionInLine, string.Format("'{0}' duplicate parameter", arg1.Text));
							        result.Add(new ident(arg1.Text, arg1.Line, arg1.CharPositionInLine)); 
						}

						}
						break;

					default:
						goto loop3;
					}
				}

				loop3:
					;

				} finally { DebugExitSubRule(3); }


				}
				break;

			}
			} finally { DebugExitSubRule(4); }


			}

		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("ident_list", 4);
			LeaveRule("ident_list", 4);
			LeaveRule_ident_list();
	        if (state.backtracking > 0) { Memoize(input, 4, ident_list_StartIndex); }

	    }
	 	DebugLocation(81, 1);
		} finally { DebugExitRule(GrammarFileName, "ident_list"); }
		return result;

	}
	// $ANTLR end "ident_list"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_statement() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_statement() {}
	// $ANTLR start "statement"
	// bek.g:87:1: statement returns [stmt result] : ( 'return' exp= iter_expr ';' |repl= 'replace' '{' cases= replace_cases '}' ( ';' )? );
	[GrammarRule("statement")]
	private stmt statement()
	{
		EnterRule_statement();
		EnterRule("statement", 5);
		TraceIn("statement", 5);
	    stmt result = default(stmt);

	    int statement_StartIndex = input.Index;

	    IToken repl = default(IToken);
	    iterexpr exp = default(iterexpr);
	    List<replacecase> cases = default(List<replacecase>);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(87, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 5)) { return result; }

			// bek.g:88:2: ( 'return' exp= iter_expr ';' |repl= 'replace' '{' cases= replace_cases '}' ( ';' )? )
			int alt6=2;
			try { DebugEnterDecision(6, decisionCanBacktrack[6]);
			int LA6_1 = input.LA(1);

			if ((LA6_1==43))
			{
				alt6 = 1;
			}
			else if ((LA6_1==42))
			{
				alt6 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return result;}
				NoViableAltException nvae = new NoViableAltException("", 6, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// bek.g:88:4: 'return' exp= iter_expr ';'
				{
				DebugLocation(88, 4);
				Match(input,43,Follow._43_in_statement307); if (state.failed) return result;
				DebugLocation(88, 16);
				PushFollow(Follow._iter_expr_in_statement311);
				exp=iter_expr();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(88, 27);
				Match(input,27,Follow._27_in_statement313); if (state.failed) return result;
				DebugLocation(89, 7);
				if (state.backtracking == 0)
				{
					result = new returnstmt(exp) ;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// bek.g:90:7: repl= 'replace' '{' cases= replace_cases '}' ( ';' )?
				{
				DebugLocation(90, 11);
				repl=(IToken)Match(input,42,Follow._42_in_statement331); if (state.failed) return result;
				DebugLocation(90, 22);
				Match(input,47,Follow._47_in_statement333); if (state.failed) return result;
				DebugLocation(90, 31);
				PushFollow(Follow._replace_cases_in_statement337);
				cases=replace_cases();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(90, 46);
				Match(input,49,Follow._49_in_statement339); if (state.failed) return result;
				DebugLocation(90, 50);
				// bek.g:90:50: ( ';' )?
				int alt5=2;
				try { DebugEnterSubRule(5);
				try { DebugEnterDecision(5, decisionCanBacktrack[5]);
				int LA5_1 = input.LA(1);

				if ((LA5_1==27))
				{
					alt5 = 1;
				}
				} finally { DebugExitDecision(5); }
				switch (alt5)
				{
				case 1:
					DebugEnterAlt(1);
					// bek.g:90:51: ';'
					{
					DebugLocation(90, 51);
					Match(input,27,Follow._27_in_statement342); if (state.failed) return result;

					}
					break;

				}
				} finally { DebugExitSubRule(5); }

				DebugLocation(91, 7);
				if (state.backtracking == 0)
				{
					result = new returnstmt(new replace(new ident(repl.Text, repl.Line, repl.CharPositionInLine), cases));
				}

				}
				break;

			}
		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("statement", 5);
			LeaveRule("statement", 5);
			LeaveRule_statement();
	        if (state.backtracking > 0) { Memoize(input, 5, statement_StartIndex); }

	    }
	 	DebugLocation(92, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return result;

	}
	// $ANTLR end "statement"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_replace_cases() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_replace_cases() {}
	// $ANTLR start "replace_cases"
	// bek.g:94:1: replace_cases returns [ List<replacecase> result ] : (pattern= str_const arrow= '==>' replace_case= replace_rhs ';' )+ (elsename= 'else' '==>' else_case= replace_rhs ';' )? ;
	[GrammarRule("replace_cases")]
	private List<replacecase> replace_cases()
	{
		EnterRule_replace_cases();
		EnterRule("replace_cases", 6);
		TraceIn("replace_cases", 6);
	    List<replacecase> result = default(List<replacecase>);

	    int replace_cases_StartIndex = input.Index;

	    IToken arrow = default(IToken);
	    IToken elsename = default(IToken);
	    strconst pattern = default(strconst);
	    expr replace_case = default(expr);
	    expr else_case = default(expr);

	     result = new List<replacecase>(); 
		try { DebugEnterRule(GrammarFileName, "replace_cases");
		DebugLocation(94, 3);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 6)) { return result; }

			// bek.g:95:4: ( (pattern= str_const arrow= '==>' replace_case= replace_rhs ';' )+ (elsename= 'else' '==>' else_case= replace_rhs ';' )? )
			DebugEnterAlt(1);
			// bek.g:95:6: (pattern= str_const arrow= '==>' replace_case= replace_rhs ';' )+ (elsename= 'else' '==>' else_case= replace_rhs ';' )?
			{
			DebugLocation(95, 6);
			// bek.g:95:6: (pattern= str_const arrow= '==>' replace_case= replace_rhs ';' )+
			int cnt7=0;
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, decisionCanBacktrack[7]);
				int LA7_1 = input.LA(1);

				if ((LA7_1==LSTRING||LA7_1==STRING))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// bek.g:95:7: pattern= str_const arrow= '==>' replace_case= replace_rhs ';'
					{
					DebugLocation(95, 14);
					PushFollow(Follow._str_const_in_replace_cases379);
					pattern=str_const();
					PopFollow();
					if (state.failed) return result;
					DebugLocation(95, 30);
					arrow=(IToken)Match(input,29,Follow._29_in_replace_cases383); if (state.failed) return result;
					DebugLocation(95, 49);
					PushFollow(Follow._replace_rhs_in_replace_cases387);
					replace_case=replace_rhs();
					PopFollow();
					if (state.failed) return result;
					DebugLocation(95, 62);
					Match(input,27,Follow._27_in_replace_cases389); if (state.failed) return result;
					DebugLocation(96, 6);
					if (state.backtracking == 0)
					{
						result.Add(new replacecase(new ident(arrow.Text, arrow.Line, arrow.CharPositionInLine), pattern, replace_case));
					}

					}
					break;

				default:
					if (cnt7 >= 1)
						goto loop7;

					if (state.backtracking>0) {state.failed=true; return result;}
					EarlyExitException eee7 = new EarlyExitException( 7, input );
					DebugRecognitionException(eee7);
					throw eee7;
				}
				cnt7++;
			}
			loop7:
				;

			} finally { DebugExitSubRule(7); }

			DebugLocation(97, 6);
			// bek.g:97:6: (elsename= 'else' '==>' else_case= replace_rhs ';' )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, decisionCanBacktrack[8]);
			int LA8_1 = input.LA(1);

			if ((LA8_1==33))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// bek.g:97:7: elsename= 'else' '==>' else_case= replace_rhs ';'
				{
				DebugLocation(97, 15);
				elsename=(IToken)Match(input,33,Follow._33_in_replace_cases409); if (state.failed) return result;
				DebugLocation(97, 23);
				Match(input,29,Follow._29_in_replace_cases411); if (state.failed) return result;
				DebugLocation(97, 38);
				PushFollow(Follow._replace_rhs_in_replace_cases415);
				else_case=replace_rhs();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(97, 51);
				Match(input,27,Follow._27_in_replace_cases417); if (state.failed) return result;
				DebugLocation(98, 6);
				if (state.backtracking == 0)
				{
					result.Add(new replacecase(new ident(elsename.Text, elsename.Line, elsename.CharPositionInLine), null, else_case));
				}

				}
				break;

			}
			} finally { DebugExitSubRule(8); }


			}

		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("replace_cases", 6);
			LeaveRule("replace_cases", 6);
			LeaveRule_replace_cases();
	        if (state.backtracking > 0) { Memoize(input, 6, replace_cases_StartIndex); }

	    }
	 	DebugLocation(99, 3);
		} finally { DebugExitRule(GrammarFileName, "replace_cases"); }
		return result;

	}
	// $ANTLR end "replace_cases"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_replace_rhs() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_replace_rhs() {}
	// $ANTLR start "replace_rhs"
	// bek.g:101:1: replace_rhs returns [expr result] : ( str_const |str= '[' param= exp_param_list ']' );
	[GrammarRule("replace_rhs")]
	private expr replace_rhs()
	{
		EnterRule_replace_rhs();
		EnterRule("replace_rhs", 7);
		TraceIn("replace_rhs", 7);
	    expr result = default(expr);

	    int replace_rhs_StartIndex = input.Index;

	    IToken str = default(IToken);
	    List<expr> param = default(List<expr>);
	    strconst str_const2 = default(strconst);

		try { DebugEnterRule(GrammarFileName, "replace_rhs");
		DebugLocation(101, 3);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 7)) { return result; }

			// bek.g:102:4: ( str_const |str= '[' param= exp_param_list ']' )
			int alt9=2;
			try { DebugEnterDecision(9, decisionCanBacktrack[9]);
			int LA9_1 = input.LA(1);

			if ((LA9_1==LSTRING||LA9_1==STRING))
			{
				alt9 = 1;
			}
			else if ((LA9_1==30))
			{
				alt9 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return result;}
				NoViableAltException nvae = new NoViableAltException("", 9, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// bek.g:102:6: str_const
				{
				DebugLocation(102, 6);
				PushFollow(Follow._str_const_in_replace_rhs446);
				str_const2=str_const();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(102, 16);
				if (state.backtracking == 0)
				{
					result = str_const2;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// bek.g:103:6: str= '[' param= exp_param_list ']'
				{
				DebugLocation(103, 9);
				str=(IToken)Match(input,30,Follow._30_in_replace_rhs457); if (state.failed) return result;
				DebugLocation(103, 19);
				PushFollow(Follow._exp_param_list_in_replace_rhs461);
				param=exp_param_list();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(103, 35);
				Match(input,31,Follow._31_in_replace_rhs463); if (state.failed) return result;
				DebugLocation(103, 39);
				if (state.backtracking == 0)
				{
					 result = new functioncall(new ident("string", str.Line, str.CharPositionInLine), param); 
				}

				}
				break;

			}
		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("replace_rhs", 7);
			LeaveRule("replace_rhs", 7);
			LeaveRule_replace_rhs();
	        if (state.backtracking > 0) { Memoize(input, 7, replace_rhs_StartIndex); }

	    }
	 	DebugLocation(104, 3);
		} finally { DebugExitRule(GrammarFileName, "replace_rhs"); }
		return result;

	}
	// $ANTLR end "replace_rhs"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_iter_expr() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_iter_expr() {}
	// $ANTLR start "iter_expr"
	// bek.g:106:1: iter_expr returns [iterexpr result] : (cases= iter_expr_main 'end' '{' endcases= case_list '}' | iter_expr_main );
	[GrammarRule("iter_expr")]
	private iterexpr iter_expr()
	{
		EnterRule_iter_expr();
		EnterRule("iter_expr", 8);
		TraceIn("iter_expr", 8);
	    iterexpr result = default(iterexpr);

	    int iter_expr_StartIndex = input.Index;

	    iterexpr cases = default(iterexpr);
	    List<itercase> endcases = default(List<itercase>);
	    iterexpr iter_expr_main3 = default(iterexpr);

		try { DebugEnterRule(GrammarFileName, "iter_expr");
		DebugLocation(106, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 8)) { return result; }

			// bek.g:107:2: (cases= iter_expr_main 'end' '{' endcases= case_list '}' | iter_expr_main )
			int alt10=2;
			try { DebugEnterDecision(10, decisionCanBacktrack[10]);
			int LA10_1 = input.LA(1);

			if ((LA10_1==39))
			{
				int LA10_2 = input.LA(2);

				if ((EvaluatePredicate(synpred10_bek_fragment)))
				{
					alt10 = 1;
				}
				else if ((true))
				{
					alt10 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 10, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return result;}
				NoViableAltException nvae = new NoViableAltException("", 10, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// bek.g:107:4: cases= iter_expr_main 'end' '{' endcases= case_list '}'
				{
				DebugLocation(107, 9);
				PushFollow(Follow._iter_expr_main_in_iter_expr489);
				cases=iter_expr_main();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(107, 25);
				Match(input,34,Follow._34_in_iter_expr491); if (state.failed) return result;
				DebugLocation(107, 31);
				Match(input,47,Follow._47_in_iter_expr493); if (state.failed) return result;
				DebugLocation(107, 43);
				PushFollow(Follow._case_list_in_iter_expr497);
				endcases=case_list();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(107, 54);
				Match(input,49,Follow._49_in_iter_expr499); if (state.failed) return result;
				DebugLocation(108, 2);
				if (state.backtracking == 0)
				{
						result = cases;
						    foreach (var ecase in endcases) ecase.endcase=true;
							result.body.AddRange(endcases);
						
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// bek.g:112:4: iter_expr_main
				{
				DebugLocation(112, 4);
				PushFollow(Follow._iter_expr_main_in_iter_expr509);
				iter_expr_main3=iter_expr_main();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(112, 19);
				if (state.backtracking == 0)
				{
					result = iter_expr_main3;
				}

				}
				break;

			}
		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("iter_expr", 8);
			LeaveRule("iter_expr", 8);
			LeaveRule_iter_expr();
	        if (state.backtracking > 0) { Memoize(input, 8, iter_expr_StartIndex); }

	    }
	 	DebugLocation(113, 1);
		} finally { DebugExitRule(GrammarFileName, "iter_expr"); }
		return result;

	}
	// $ANTLR end "iter_expr"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_iter_expr_main() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_iter_expr_main() {}
	// $ANTLR start "iter_expr_main"
	// bek.g:115:1: iter_expr_main returns [iterexpr result] : 'iter' '(' binder= ID 'in' str= ID ')' init= iter_init '{' body= case_list '}' ;
	[GrammarRule("iter_expr_main")]
	private iterexpr iter_expr_main()
	{
		EnterRule_iter_expr_main();
		EnterRule("iter_expr_main", 9);
		TraceIn("iter_expr_main", 9);
	    iterexpr result = default(iterexpr);

	    int iter_expr_main_StartIndex = input.Index;

	    IToken binder = default(IToken);
	    IToken str = default(IToken);
	    iterinit init = default(iterinit);
	    List<itercase> body = default(List<itercase>);

		try { DebugEnterRule(GrammarFileName, "iter_expr_main");
		DebugLocation(115, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 9)) { return result; }

			// bek.g:116:2: ( 'iter' '(' binder= ID 'in' str= ID ')' init= iter_init '{' body= case_list '}' )
			DebugEnterAlt(1);
			// bek.g:116:4: 'iter' '(' binder= ID 'in' str= ID ')' init= iter_init '{' body= case_list '}'
			{
			DebugLocation(116, 4);
			Match(input,39,Follow._39_in_iter_expr_main526); if (state.failed) return result;
			DebugLocation(116, 11);
			Match(input,20,Follow._20_in_iter_expr_main528); if (state.failed) return result;
			DebugLocation(116, 21);
			binder=(IToken)Match(input,ID,Follow._ID_in_iter_expr_main532); if (state.failed) return result;
			DebugLocation(116, 25);
			Match(input,38,Follow._38_in_iter_expr_main534); if (state.failed) return result;
			DebugLocation(116, 33);
			str=(IToken)Match(input,ID,Follow._ID_in_iter_expr_main538); if (state.failed) return result;
			DebugLocation(116, 37);
			Match(input,21,Follow._21_in_iter_expr_main540); if (state.failed) return result;
			DebugLocation(117, 15);
			PushFollow(Follow._iter_init_in_iter_expr_main555);
			init=iter_init();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(118, 11);
			Match(input,47,Follow._47_in_iter_expr_main567); if (state.failed) return result;
			DebugLocation(119, 21);
			PushFollow(Follow._case_list_in_iter_expr_main590);
			body=case_list();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(120, 14);
			Match(input,49,Follow._49_in_iter_expr_main605); if (state.failed) return result;
			DebugLocation(121, 5);
			if (state.backtracking == 0)
			{
				  result = new iterexpr(new ident(binder.Text, binder.Line, binder.CharPositionInLine),
				                              new ident(str.Text, str.Line, str.CharPositionInLine),	
								              init,
								              body);
				    
			}

			}

		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("iter_expr_main", 9);
			LeaveRule("iter_expr_main", 9);
			LeaveRule_iter_expr_main();
	        if (state.backtracking > 0) { Memoize(input, 9, iter_expr_main_StartIndex); }

	    }
	 	DebugLocation(126, 1);
		} finally { DebugExitRule(GrammarFileName, "iter_expr_main"); }
		return result;

	}
	// $ANTLR end "iter_expr_main"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_iter_init() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_iter_init() {}
	// $ANTLR start "iter_init"
	// bek.g:128:1: iter_init returns [iterinit result] : (| '[' (assgn= iter_const_assgn ';' )* ']' );
	[GrammarRule("iter_init")]
	private iterinit iter_init()
	{
		EnterRule_iter_init();
		EnterRule("iter_init", 10);
		TraceIn("iter_init", 10);
	    iterinit result = default(iterinit);

	    int iter_init_StartIndex = input.Index;

	    iterassgn assgn = default(iterassgn);

	     result = new iterinit(); 
		try { DebugEnterRule(GrammarFileName, "iter_init");
		DebugLocation(128, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 10)) { return result; }

			// bek.g:130:2: (| '[' (assgn= iter_const_assgn ';' )* ']' )
			int alt12=2;
			try { DebugEnterDecision(12, decisionCanBacktrack[12]);
			int LA12_1 = input.LA(1);

			if ((LA12_1==47))
			{
				alt12 = 1;
			}
			else if ((LA12_1==30))
			{
				alt12 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return result;}
				NoViableAltException nvae = new NoViableAltException("", 12, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// bek.g:131:2: 
				{
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// bek.g:131:4: '[' (assgn= iter_const_assgn ';' )* ']'
				{
				DebugLocation(131, 4);
				Match(input,30,Follow._30_in_iter_init641); if (state.failed) return result;
				DebugLocation(131, 8);
				// bek.g:131:8: (assgn= iter_const_assgn ';' )*
				try { DebugEnterSubRule(11);
				while (true)
				{
					int alt11=2;
					try { DebugEnterDecision(11, decisionCanBacktrack[11]);
					int LA11_1 = input.LA(1);

					if ((LA11_1==ID))
					{
						alt11 = 1;
					}


					} finally { DebugExitDecision(11); }
					switch ( alt11 )
					{
					case 1:
						DebugEnterAlt(1);
						// bek.g:131:9: assgn= iter_const_assgn ';'
						{
						DebugLocation(131, 14);
						PushFollow(Follow._iter_const_assgn_in_iter_init646);
						assgn=iter_const_assgn();
						PopFollow();
						if (state.failed) return result;
						DebugLocation(131, 32);
						Match(input,27,Follow._27_in_iter_init648); if (state.failed) return result;
						DebugLocation(131, 36);
						if (state.backtracking == 0)
						{
							 result.assgns.Add(assgn); 
						}

						}
						break;

					default:
						goto loop11;
					}
				}

				loop11:
					;

				} finally { DebugExitSubRule(11); }

				DebugLocation(131, 77);
				Match(input,31,Follow._31_in_iter_init654); if (state.failed) return result;

				}
				break;

			}
		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("iter_init", 10);
			LeaveRule("iter_init", 10);
			LeaveRule_iter_init();
	        if (state.backtracking > 0) { Memoize(input, 10, iter_init_StartIndex); }

	    }
	 	DebugLocation(132, 1);
		} finally { DebugExitRule(GrammarFileName, "iter_init"); }
		return result;

	}
	// $ANTLR end "iter_init"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_iter_const_assgn() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_iter_const_assgn() {}
	// $ANTLR start "iter_const_assgn"
	// bek.g:134:1: iter_const_assgn returns [iterassgn result] : (lhs= ID ':=' rhschar= char_const |lhs= ID ':=' rhsbool= bool_const );
	[GrammarRule("iter_const_assgn")]
	private iterassgn iter_const_assgn()
	{
		EnterRule_iter_const_assgn();
		EnterRule("iter_const_assgn", 11);
		TraceIn("iter_const_assgn", 11);
	    iterassgn result = default(iterassgn);

	    int iter_const_assgn_StartIndex = input.Index;

	    IToken lhs = default(IToken);
	    charconst rhschar = default(charconst);
	    boolconst rhsbool = default(boolconst);

		try { DebugEnterRule(GrammarFileName, "iter_const_assgn");
		DebugLocation(134, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 11)) { return result; }

			// bek.g:135:2: (lhs= ID ':=' rhschar= char_const |lhs= ID ':=' rhsbool= bool_const )
			int alt13=2;
			try { DebugEnterDecision(13, decisionCanBacktrack[13]);
			int LA13_1 = input.LA(1);

			if ((LA13_1==ID))
			{
				int LA13_2 = input.LA(2);

				if ((LA13_2==26))
				{
					int LA13_3 = input.LA(3);

					if ((LA13_3==CHAR||LA13_3==INT))
					{
						alt13 = 1;
					}
					else if ((LA13_3==35||LA13_3==45))
					{
						alt13 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return result;}
						NoViableAltException nvae = new NoViableAltException("", 13, 2, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 13, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return result;}
				NoViableAltException nvae = new NoViableAltException("", 13, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// bek.g:135:4: lhs= ID ':=' rhschar= char_const
				{
				DebugLocation(135, 7);
				lhs=(IToken)Match(input,ID,Follow._ID_in_iter_const_assgn672); if (state.failed) return result;
				DebugLocation(135, 11);
				Match(input,26,Follow._26_in_iter_const_assgn674); if (state.failed) return result;
				DebugLocation(135, 23);
				PushFollow(Follow._char_const_in_iter_const_assgn678);
				rhschar=char_const();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(135, 36);
				if (state.backtracking == 0)
				{
					result = new iterassgn(new ident(lhs.Text, lhs.Line, lhs.CharPositionInLine), rhschar);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// bek.g:136:4: lhs= ID ':=' rhsbool= bool_const
				{
				DebugLocation(136, 7);
				lhs=(IToken)Match(input,ID,Follow._ID_in_iter_const_assgn689); if (state.failed) return result;
				DebugLocation(136, 11);
				Match(input,26,Follow._26_in_iter_const_assgn691); if (state.failed) return result;
				DebugLocation(136, 23);
				PushFollow(Follow._bool_const_in_iter_const_assgn695);
				rhsbool=bool_const();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(136, 36);
				if (state.backtracking == 0)
				{
					result = new iterassgn(new ident(lhs.Text, lhs.Line, lhs.CharPositionInLine), rhsbool);
				}

				}
				break;

			}
		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("iter_const_assgn", 11);
			LeaveRule("iter_const_assgn", 11);
			LeaveRule_iter_const_assgn();
	        if (state.backtracking > 0) { Memoize(input, 11, iter_const_assgn_StartIndex); }

	    }
	 	DebugLocation(137, 1);
		} finally { DebugExitRule(GrammarFileName, "iter_const_assgn"); }
		return result;

	}
	// $ANTLR end "iter_const_assgn"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_case_list() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_case_list() {}
	// $ANTLR start "case_list"
	// bek.g:139:1: case_list returns [List<itercase> result] : ( case_stmt )+ ;
	[GrammarRule("case_list")]
	private List<itercase> case_list()
	{
		EnterRule_case_list();
		EnterRule("case_list", 12);
		TraceIn("case_list", 12);
	    List<itercase> result = default(List<itercase>);

	    int case_list_StartIndex = input.Index;

	    itercase case_stmt4 = default(itercase);

	     result = new List<itercase>(); 
		try { DebugEnterRule(GrammarFileName, "case_list");
		DebugLocation(139, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 12)) { return result; }

			// bek.g:140:5: ( ( case_stmt )+ )
			DebugEnterAlt(1);
			// bek.g:140:7: ( case_stmt )+
			{
			DebugLocation(140, 7);
			// bek.g:140:7: ( case_stmt )+
			int cnt14=0;
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, decisionCanBacktrack[14]);
				int LA14_1 = input.LA(1);

				if ((LA14_1==32||LA14_1==34))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch (alt14)
				{
				case 1:
					DebugEnterAlt(1);
					// bek.g:140:8: case_stmt
					{
					DebugLocation(140, 8);
					PushFollow(Follow._case_stmt_in_case_list722);
					case_stmt4=case_stmt();
					PopFollow();
					if (state.failed) return result;
					DebugLocation(140, 18);
					if (state.backtracking == 0)
					{
						 result.Add(case_stmt4); 
					}

					}
					break;

				default:
					if (cnt14 >= 1)
						goto loop14;

					if (state.backtracking>0) {state.failed=true; return result;}
					EarlyExitException eee14 = new EarlyExitException( 14, input );
					DebugRecognitionException(eee14);
					throw eee14;
				}
				cnt14++;
			}
			loop14:
				;

			} finally { DebugExitSubRule(14); }


			}

		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("case_list", 12);
			LeaveRule("case_list", 12);
			LeaveRule_case_list();
	        if (state.backtracking > 0) { Memoize(input, 12, case_list_StartIndex); }

	    }
	 	DebugLocation(141, 1);
		} finally { DebugExitRule(GrammarFileName, "case_list"); }
		return result;

	}
	// $ANTLR end "case_list"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_case_stmt() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_case_stmt() {}
	// $ANTLR start "case_stmt"
	// bek.g:143:1: case_stmt returns [itercase result] : ( 'case' '(' comp_expr ')' ':' body= iterstmt_list_or_ite | 'end' 'case' '(' comp_expr ')' ':' body= iterstmt_list_or_ite );
	[GrammarRule("case_stmt")]
	private itercase case_stmt()
	{
		EnterRule_case_stmt();
		EnterRule("case_stmt", 13);
		TraceIn("case_stmt", 13);
	    itercase result = default(itercase);

	    int case_stmt_StartIndex = input.Index;

	    List<iterstmt> body = default(List<iterstmt>);
	    expr comp_expr5 = default(expr);
	    expr comp_expr6 = default(expr);

		try { DebugEnterRule(GrammarFileName, "case_stmt");
		DebugLocation(143, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 13)) { return result; }

			// bek.g:144:2: ( 'case' '(' comp_expr ')' ':' body= iterstmt_list_or_ite | 'end' 'case' '(' comp_expr ')' ':' body= iterstmt_list_or_ite )
			int alt15=2;
			try { DebugEnterDecision(15, decisionCanBacktrack[15]);
			int LA15_1 = input.LA(1);

			if ((LA15_1==32))
			{
				alt15 = 1;
			}
			else if ((LA15_1==34))
			{
				alt15 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return result;}
				NoViableAltException nvae = new NoViableAltException("", 15, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// bek.g:144:4: 'case' '(' comp_expr ')' ':' body= iterstmt_list_or_ite
				{
				DebugLocation(144, 4);
				Match(input,32,Follow._32_in_case_stmt742); if (state.failed) return result;
				DebugLocation(144, 11);
				Match(input,20,Follow._20_in_case_stmt744); if (state.failed) return result;
				DebugLocation(144, 16);
				PushFollow(Follow._comp_expr_in_case_stmt747);
				comp_expr5=comp_expr();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(144, 26);
				Match(input,21,Follow._21_in_case_stmt749); if (state.failed) return result;
				DebugLocation(144, 30);
				Match(input,25,Follow._25_in_case_stmt751); if (state.failed) return result;
				DebugLocation(145, 11);
				PushFollow(Follow._iterstmt_list_or_ite_in_case_stmt761);
				body=iterstmt_list_or_ite();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(146, 2);
				if (state.backtracking == 0)
				{
					 result = new itercase(comp_expr5,
						                         body);
					    
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// bek.g:149:4: 'end' 'case' '(' comp_expr ')' ':' body= iterstmt_list_or_ite
				{
				DebugLocation(149, 4);
				Match(input,34,Follow._34_in_case_stmt769); if (state.failed) return result;
				DebugLocation(149, 10);
				Match(input,32,Follow._32_in_case_stmt771); if (state.failed) return result;
				DebugLocation(149, 17);
				Match(input,20,Follow._20_in_case_stmt773); if (state.failed) return result;
				DebugLocation(149, 21);
				PushFollow(Follow._comp_expr_in_case_stmt775);
				comp_expr6=comp_expr();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(149, 31);
				Match(input,21,Follow._21_in_case_stmt777); if (state.failed) return result;
				DebugLocation(149, 35);
				Match(input,25,Follow._25_in_case_stmt779); if (state.failed) return result;
				DebugLocation(150, 11);
				PushFollow(Follow._iterstmt_list_or_ite_in_case_stmt789);
				body=iterstmt_list_or_ite();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(151, 5);
				if (state.backtracking == 0)
				{
					 result = new itercase(comp_expr6, 
						                        body);
					      result.endcase = true;
					    
				}

				}
				break;

			}
		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("case_stmt", 13);
			LeaveRule("case_stmt", 13);
			LeaveRule_case_stmt();
	        if (state.backtracking > 0) { Memoize(input, 13, case_stmt_StartIndex); }

	    }
	 	DebugLocation(155, 1);
		} finally { DebugExitRule(GrammarFileName, "case_stmt"); }
		return result;

	}
	// $ANTLR end "case_stmt"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_iterstmt_list_or_ite() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_iterstmt_list_or_ite() {}
	// $ANTLR start "iterstmt_list_or_ite"
	// bek.g:157:1: iterstmt_list_or_ite returns [List<iterstmt> result] : ( ifthenelse_pairs | iterstmt_list );
	[GrammarRule("iterstmt_list_or_ite")]
	private List<iterstmt> iterstmt_list_or_ite()
	{
		EnterRule_iterstmt_list_or_ite();
		EnterRule("iterstmt_list_or_ite", 14);
		TraceIn("iterstmt_list_or_ite", 14);
	    List<iterstmt> result = default(List<iterstmt>);

	    int iterstmt_list_or_ite_StartIndex = input.Index;

	    List<KeyValuePair<expr,List<iterstmt>>> ifthenelse_pairs7 = default(List<KeyValuePair<expr,List<iterstmt>>>);
	    List<iterstmt> iterstmt_list8 = default(List<iterstmt>);

		try { DebugEnterRule(GrammarFileName, "iterstmt_list_or_ite");
		DebugLocation(157, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 14)) { return result; }

			// bek.g:158:5: ( ifthenelse_pairs | iterstmt_list )
			int alt16=2;
			try { DebugEnterDecision(16, decisionCanBacktrack[16]);
			int LA16_1 = input.LA(1);

			if ((LA16_1==37))
			{
				alt16 = 1;
			}
			else if ((LA16_1==ID||LA16_1==41||LA16_1==44||LA16_1==46))
			{
				alt16 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return result;}
				NoViableAltException nvae = new NoViableAltException("", 16, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// bek.g:158:7: ifthenelse_pairs
				{
				DebugLocation(158, 7);
				PushFollow(Follow._ifthenelse_pairs_in_iterstmt_list_or_ite813);
				ifthenelse_pairs7=ifthenelse_pairs();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(158, 24);
				if (state.backtracking == 0)
				{
					result = new List<iterstmt>(); result.Add(ifthenelse.Mk(ifthenelse_pairs7));
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// bek.g:159:4: iterstmt_list
				{
				DebugLocation(159, 4);
				PushFollow(Follow._iterstmt_list_in_iterstmt_list_or_ite820);
				iterstmt_list8=iterstmt_list();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(159, 18);
				if (state.backtracking == 0)
				{
					result = iterstmt_list8;
				}

				}
				break;

			}
		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("iterstmt_list_or_ite", 14);
			LeaveRule("iterstmt_list_or_ite", 14);
			LeaveRule_iterstmt_list_or_ite();
	        if (state.backtracking > 0) { Memoize(input, 14, iterstmt_list_or_ite_StartIndex); }

	    }
	 	DebugLocation(160, 1);
		} finally { DebugExitRule(GrammarFileName, "iterstmt_list_or_ite"); }
		return result;

	}
	// $ANTLR end "iterstmt_list_or_ite"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_ifthenelse_pairs() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_ifthenelse_pairs() {}
	// $ANTLR start "ifthenelse_pairs"
	// bek.g:162:1: ifthenelse_pairs returns [List<KeyValuePair<expr,List<iterstmt>>> result] : 'if' '(' cond= comp_expr ')' '{' tcase= iterstmt_list_or_ite '}' ( 'else' 'if' '(' elseif= comp_expr ')' '{' elseifcase= iterstmt_list_or_ite '}' )* 'else' '{' fcase= iterstmt_list_or_ite '}' ;
	[GrammarRule("ifthenelse_pairs")]
	private List<KeyValuePair<expr,List<iterstmt>>> ifthenelse_pairs()
	{
		EnterRule_ifthenelse_pairs();
		EnterRule("ifthenelse_pairs", 15);
		TraceIn("ifthenelse_pairs", 15);
	    List<KeyValuePair<expr,List<iterstmt>>> result = default(List<KeyValuePair<expr,List<iterstmt>>>);

	    int ifthenelse_pairs_StartIndex = input.Index;

	    expr cond = default(expr);
	    List<iterstmt> tcase = default(List<iterstmt>);
	    expr elseif = default(expr);
	    List<iterstmt> elseifcase = default(List<iterstmt>);
	    List<iterstmt> fcase = default(List<iterstmt>);

	     result = new List<KeyValuePair<expr,List<iterstmt>>>(); 
		try { DebugEnterRule(GrammarFileName, "ifthenelse_pairs");
		DebugLocation(162, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 15)) { return result; }

			// bek.g:163:5: ( 'if' '(' cond= comp_expr ')' '{' tcase= iterstmt_list_or_ite '}' ( 'else' 'if' '(' elseif= comp_expr ')' '{' elseifcase= iterstmt_list_or_ite '}' )* 'else' '{' fcase= iterstmt_list_or_ite '}' )
			DebugEnterAlt(1);
			// bek.g:163:8: 'if' '(' cond= comp_expr ')' '{' tcase= iterstmt_list_or_ite '}' ( 'else' 'if' '(' elseif= comp_expr ')' '{' elseifcase= iterstmt_list_or_ite '}' )* 'else' '{' fcase= iterstmt_list_or_ite '}'
			{
			DebugLocation(163, 8);
			Match(input,37,Follow._37_in_ifthenelse_pairs846); if (state.failed) return result;
			DebugLocation(163, 13);
			Match(input,20,Follow._20_in_ifthenelse_pairs848); if (state.failed) return result;
			DebugLocation(163, 21);
			PushFollow(Follow._comp_expr_in_ifthenelse_pairs852);
			cond=comp_expr();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(163, 32);
			Match(input,21,Follow._21_in_ifthenelse_pairs854); if (state.failed) return result;
			DebugLocation(163, 36);
			Match(input,47,Follow._47_in_ifthenelse_pairs856); if (state.failed) return result;
			DebugLocation(163, 45);
			PushFollow(Follow._iterstmt_list_or_ite_in_ifthenelse_pairs860);
			tcase=iterstmt_list_or_ite();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(163, 67);
			Match(input,49,Follow._49_in_ifthenelse_pairs862); if (state.failed) return result;
			DebugLocation(164, 7);
			if (state.backtracking == 0)
			{
				result.Add(new KeyValuePair<expr,List<iterstmt>>(cond, tcase)); 
			}
			DebugLocation(165, 4);
			// bek.g:165:4: ( 'else' 'if' '(' elseif= comp_expr ')' '{' elseifcase= iterstmt_list_or_ite '}' )*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, decisionCanBacktrack[17]);
				int LA17_1 = input.LA(1);

				if ((LA17_1==33))
				{
					int LA17_2 = input.LA(2);

					if ((LA17_2==37))
					{
						alt17 = 1;
					}


				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// bek.g:165:5: 'else' 'if' '(' elseif= comp_expr ')' '{' elseifcase= iterstmt_list_or_ite '}'
					{
					DebugLocation(165, 5);
					Match(input,33,Follow._33_in_ifthenelse_pairs877); if (state.failed) return result;
					DebugLocation(165, 12);
					Match(input,37,Follow._37_in_ifthenelse_pairs879); if (state.failed) return result;
					DebugLocation(165, 17);
					Match(input,20,Follow._20_in_ifthenelse_pairs881); if (state.failed) return result;
					DebugLocation(165, 27);
					PushFollow(Follow._comp_expr_in_ifthenelse_pairs885);
					elseif=comp_expr();
					PopFollow();
					if (state.failed) return result;
					DebugLocation(165, 38);
					Match(input,21,Follow._21_in_ifthenelse_pairs887); if (state.failed) return result;
					DebugLocation(165, 42);
					Match(input,47,Follow._47_in_ifthenelse_pairs889); if (state.failed) return result;
					DebugLocation(165, 56);
					PushFollow(Follow._iterstmt_list_or_ite_in_ifthenelse_pairs893);
					elseifcase=iterstmt_list_or_ite();
					PopFollow();
					if (state.failed) return result;
					DebugLocation(165, 78);
					Match(input,49,Follow._49_in_ifthenelse_pairs895); if (state.failed) return result;
					DebugLocation(166, 6);
					if (state.backtracking == 0)
					{
						result.Add(new KeyValuePair<expr,List<iterstmt>>(elseif, elseifcase)); 
					}

					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }

			DebugLocation(167, 4);
			Match(input,33,Follow._33_in_ifthenelse_pairs910); if (state.failed) return result;
			DebugLocation(167, 11);
			Match(input,47,Follow._47_in_ifthenelse_pairs912); if (state.failed) return result;
			DebugLocation(167, 20);
			PushFollow(Follow._iterstmt_list_or_ite_in_ifthenelse_pairs916);
			fcase=iterstmt_list_or_ite();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(167, 42);
			Match(input,49,Follow._49_in_ifthenelse_pairs918); if (state.failed) return result;
			DebugLocation(168, 6);
			if (state.backtracking == 0)
			{
				result.Add(new KeyValuePair<expr,List<iterstmt>>(null, fcase)); 
			}

			}

		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("ifthenelse_pairs", 15);
			LeaveRule("ifthenelse_pairs", 15);
			LeaveRule_ifthenelse_pairs();
	        if (state.backtracking > 0) { Memoize(input, 15, ifthenelse_pairs_StartIndex); }

	    }
	 	DebugLocation(169, 1);
		} finally { DebugExitRule(GrammarFileName, "ifthenelse_pairs"); }
		return result;

	}
	// $ANTLR end "ifthenelse_pairs"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_iterstmt_list() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_iterstmt_list() {}
	// $ANTLR start "iterstmt_list"
	// bek.g:171:1: iterstmt_list returns [List<iterstmt> result] : ( iter_stmt ';' )+ ;
	[GrammarRule("iterstmt_list")]
	private List<iterstmt> iterstmt_list()
	{
		EnterRule_iterstmt_list();
		EnterRule("iterstmt_list", 16);
		TraceIn("iterstmt_list", 16);
	    List<iterstmt> result = default(List<iterstmt>);

	    int iterstmt_list_StartIndex = input.Index;

	    iterstmt iter_stmt9 = default(iterstmt);

	     result = new List<iterstmt>(); 
		try { DebugEnterRule(GrammarFileName, "iterstmt_list");
		DebugLocation(171, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 16)) { return result; }

			// bek.g:172:5: ( ( iter_stmt ';' )+ )
			DebugEnterAlt(1);
			// bek.g:172:7: ( iter_stmt ';' )+
			{
			DebugLocation(172, 7);
			// bek.g:172:7: ( iter_stmt ';' )+
			int cnt18=0;
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, decisionCanBacktrack[18]);
				int LA18_1 = input.LA(1);

				if ((LA18_1==ID||LA18_1==41||LA18_1==44||LA18_1==46))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch (alt18)
				{
				case 1:
					DebugEnterAlt(1);
					// bek.g:172:8: iter_stmt ';'
					{
					DebugLocation(172, 8);
					PushFollow(Follow._iter_stmt_in_iterstmt_list950);
					iter_stmt9=iter_stmt();
					PopFollow();
					if (state.failed) return result;
					DebugLocation(172, 18);
					Match(input,27,Follow._27_in_iterstmt_list952); if (state.failed) return result;
					DebugLocation(172, 22);
					if (state.backtracking == 0)
					{
						 result.Add(iter_stmt9); 
					}

					}
					break;

				default:
					if (cnt18 >= 1)
						goto loop18;

					if (state.backtracking>0) {state.failed=true; return result;}
					EarlyExitException eee18 = new EarlyExitException( 18, input );
					DebugRecognitionException(eee18);
					throw eee18;
				}
				cnt18++;
			}
			loop18:
				;

			} finally { DebugExitSubRule(18); }


			}

		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("iterstmt_list", 16);
			LeaveRule("iterstmt_list", 16);
			LeaveRule_iterstmt_list();
	        if (state.backtracking > 0) { Memoize(input, 16, iterstmt_list_StartIndex); }

	    }
	 	DebugLocation(173, 1);
		} finally { DebugExitRule(GrammarFileName, "iterstmt_list"); }
		return result;

	}
	// $ANTLR end "iterstmt_list"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_iter_stmt() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_iter_stmt() {}
	// $ANTLR start "iter_stmt"
	// bek.g:175:1: iter_stmt returns [iterstmt result] : ( 'skip' |name= ID ':=' rhs= comp_expr | yield_stmt | raise_stmt );
	[GrammarRule("iter_stmt")]
	private iterstmt iter_stmt()
	{
		EnterRule_iter_stmt();
		EnterRule("iter_stmt", 17);
		TraceIn("iter_stmt", 17);
	    iterstmt result = default(iterstmt);

	    int iter_stmt_StartIndex = input.Index;

	    IToken name = default(IToken);
	    expr rhs = default(expr);
	    iterstmt yield_stmt10 = default(iterstmt);
	    iterstmt raise_stmt11 = default(iterstmt);

		try { DebugEnterRule(GrammarFileName, "iter_stmt");
		DebugLocation(175, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 17)) { return result; }

			// bek.g:176:2: ( 'skip' |name= ID ':=' rhs= comp_expr | yield_stmt | raise_stmt )
			int alt19=4;
			try { DebugEnterDecision(19, decisionCanBacktrack[19]);
			switch (input.LA(1))
			{
			case 44:
				{
				alt19 = 1;
				}
				break;
			case ID:
				{
				alt19 = 2;
				}
				break;
			case 46:
				{
				alt19 = 3;
				}
				break;
			case 41:
				{
				alt19 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 19, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// bek.g:176:4: 'skip'
				{
				DebugLocation(176, 4);
				Match(input,44,Follow._44_in_iter_stmt971); if (state.failed) return result;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// bek.g:177:4: name= ID ':=' rhs= comp_expr
				{
				DebugLocation(177, 8);
				name=(IToken)Match(input,ID,Follow._ID_in_iter_stmt979); if (state.failed) return result;
				DebugLocation(177, 12);
				Match(input,26,Follow._26_in_iter_stmt981); if (state.failed) return result;
				DebugLocation(177, 20);
				PushFollow(Follow._comp_expr_in_iter_stmt985);
				rhs=comp_expr();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(177, 31);
				if (state.backtracking == 0)
				{
					 result = new iterassgn(new ident(name.Text, name.Line, name.CharPositionInLine), rhs); 
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// bek.g:178:4: yield_stmt
				{
				DebugLocation(178, 4);
				PushFollow(Follow._yield_stmt_in_iter_stmt992);
				yield_stmt10=yield_stmt();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(178, 15);
				if (state.backtracking == 0)
				{
					result = yield_stmt10;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// bek.g:179:4: raise_stmt
				{
				DebugLocation(179, 4);
				PushFollow(Follow._raise_stmt_in_iter_stmt999);
				raise_stmt11=raise_stmt();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(179, 15);
				if (state.backtracking == 0)
				{
					result = raise_stmt11;
				}

				}
				break;

			}
		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("iter_stmt", 17);
			LeaveRule("iter_stmt", 17);
			LeaveRule_iter_stmt();
	        if (state.backtracking > 0) { Memoize(input, 17, iter_stmt_StartIndex); }

	    }
	 	DebugLocation(180, 4);
		} finally { DebugExitRule(GrammarFileName, "iter_stmt"); }
		return result;

	}
	// $ANTLR end "iter_stmt"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_yield_stmt() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_yield_stmt() {}
	// $ANTLR start "yield_stmt"
	// bek.g:182:1: yield_stmt returns [iterstmt result] : ( 'yield' '(' args= yield_expr_list ')' | 'yield' '(' ')' );
	[GrammarRule("yield_stmt")]
	private iterstmt yield_stmt()
	{
		EnterRule_yield_stmt();
		EnterRule("yield_stmt", 18);
		TraceIn("yield_stmt", 18);
	    iterstmt result = default(iterstmt);

	    int yield_stmt_StartIndex = input.Index;

	    List<expr> args = default(List<expr>);

		try { DebugEnterRule(GrammarFileName, "yield_stmt");
		DebugLocation(182, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 18)) { return result; }

			// bek.g:183:2: ( 'yield' '(' args= yield_expr_list ')' | 'yield' '(' ')' )
			int alt20=2;
			try { DebugEnterDecision(20, decisionCanBacktrack[20]);
			int LA20_1 = input.LA(1);

			if ((LA20_1==46))
			{
				int LA20_2 = input.LA(2);

				if ((LA20_2==20))
				{
					int LA20_3 = input.LA(3);

					if ((LA20_3==21))
					{
						alt20 = 2;
					}
					else if ((LA20_3==CHAR||LA20_3==ID||(LA20_3>=INT && LA20_3<=LSTRING)||(LA20_3>=STRING && LA20_3<=UNARY_OP)||LA20_3==20||LA20_3==30||LA20_3==35||LA20_3==45))
					{
						alt20 = 1;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return result;}
						NoViableAltException nvae = new NoViableAltException("", 20, 2, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 20, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return result;}
				NoViableAltException nvae = new NoViableAltException("", 20, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// bek.g:183:4: 'yield' '(' args= yield_expr_list ')'
				{
				DebugLocation(183, 4);
				Match(input,46,Follow._46_in_yield_stmt1019); if (state.failed) return result;
				DebugLocation(183, 12);
				Match(input,20,Follow._20_in_yield_stmt1021); if (state.failed) return result;
				DebugLocation(183, 20);
				PushFollow(Follow._yield_expr_list_in_yield_stmt1025);
				args=yield_expr_list();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(183, 37);
				Match(input,21,Follow._21_in_yield_stmt1027); if (state.failed) return result;
				DebugLocation(183, 41);
				if (state.backtracking == 0)
				{
					result = new yieldstmt(args); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// bek.g:184:6: 'yield' '(' ')'
				{
				DebugLocation(184, 6);
				Match(input,46,Follow._46_in_yield_stmt1036); if (state.failed) return result;
				DebugLocation(184, 14);
				Match(input,20,Follow._20_in_yield_stmt1038); if (state.failed) return result;
				DebugLocation(184, 18);
				Match(input,21,Follow._21_in_yield_stmt1040); if (state.failed) return result;
				DebugLocation(184, 22);
				if (state.backtracking == 0)
				{
					 result = new yieldstmt( new List<expr>() ); 
				}

				}
				break;

			}
		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("yield_stmt", 18);
			LeaveRule("yield_stmt", 18);
			LeaveRule_yield_stmt();
	        if (state.backtracking > 0) { Memoize(input, 18, yield_stmt_StartIndex); }

	    }
	 	DebugLocation(185, 1);
		} finally { DebugExitRule(GrammarFileName, "yield_stmt"); }
		return result;

	}
	// $ANTLR end "yield_stmt"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_raise_stmt() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_raise_stmt() {}
	// $ANTLR start "raise_stmt"
	// bek.g:187:1: raise_stmt returns [iterstmt result] : 'raise' name= ID ;
	[GrammarRule("raise_stmt")]
	private iterstmt raise_stmt()
	{
		EnterRule_raise_stmt();
		EnterRule("raise_stmt", 19);
		TraceIn("raise_stmt", 19);
	    iterstmt result = default(iterstmt);

	    int raise_stmt_StartIndex = input.Index;

	    IToken name = default(IToken);

		try { DebugEnterRule(GrammarFileName, "raise_stmt");
		DebugLocation(187, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 19)) { return result; }

			// bek.g:188:2: ( 'raise' name= ID )
			DebugEnterAlt(1);
			// bek.g:188:4: 'raise' name= ID
			{
			DebugLocation(188, 4);
			Match(input,41,Follow._41_in_raise_stmt1057); if (state.failed) return result;
			DebugLocation(188, 16);
			name=(IToken)Match(input,ID,Follow._ID_in_raise_stmt1061); if (state.failed) return result;
			DebugLocation(188, 20);
			if (state.backtracking == 0)
			{
				result = new raisestmt(name.Text); 
			}

			}

		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("raise_stmt", 19);
			LeaveRule("raise_stmt", 19);
			LeaveRule_raise_stmt();
	        if (state.backtracking > 0) { Memoize(input, 19, raise_stmt_StartIndex); }

	    }
	 	DebugLocation(189, 1);
		} finally { DebugExitRule(GrammarFileName, "raise_stmt"); }
		return result;

	}
	// $ANTLR end "raise_stmt"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_yield_expr_list() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_yield_expr_list() {}
	// $ANTLR start "yield_expr_list"
	// bek.g:191:1: yield_expr_list returns [ List<expr> result] : arg1= comp_expr ( ',' arg= comp_expr )* ;
	[GrammarRule("yield_expr_list")]
	private List<expr> yield_expr_list()
	{
		EnterRule_yield_expr_list();
		EnterRule("yield_expr_list", 20);
		TraceIn("yield_expr_list", 20);
	    List<expr> result = default(List<expr>);

	    int yield_expr_list_StartIndex = input.Index;

	    expr arg1 = default(expr);
	    expr arg = default(expr);

	     result = new List<expr>(); 
		try { DebugEnterRule(GrammarFileName, "yield_expr_list");
		DebugLocation(191, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 20)) { return result; }

			// bek.g:192:5: (arg1= comp_expr ( ',' arg= comp_expr )* )
			DebugEnterAlt(1);
			// bek.g:192:7: arg1= comp_expr ( ',' arg= comp_expr )*
			{
			DebugLocation(192, 11);
			PushFollow(Follow._comp_expr_in_yield_expr_list1088);
			arg1=comp_expr();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(192, 22);
			if (state.backtracking == 0)
			{
				 result.Add(arg1);
			}
			DebugLocation(193, 2);
			// bek.g:193:2: ( ',' arg= comp_expr )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, decisionCanBacktrack[21]);
				int LA21_1 = input.LA(1);

				if ((LA21_1==24))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// bek.g:193:3: ',' arg= comp_expr
					{
					DebugLocation(193, 3);
					Match(input,24,Follow._24_in_yield_expr_list1095); if (state.failed) return result;
					DebugLocation(193, 10);
					PushFollow(Follow._comp_expr_in_yield_expr_list1099);
					arg=comp_expr();
					PopFollow();
					if (state.failed) return result;
					DebugLocation(193, 21);
					if (state.backtracking == 0)
					{
						 result.Add(arg);
					}

					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }


			}

		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("yield_expr_list", 20);
			LeaveRule("yield_expr_list", 20);
			LeaveRule_yield_expr_list();
	        if (state.backtracking > 0) { Memoize(input, 20, yield_expr_list_StartIndex); }

	    }
	 	DebugLocation(194, 1);
		} finally { DebugExitRule(GrammarFileName, "yield_expr_list"); }
		return result;

	}
	// $ANTLR end "yield_expr_list"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_comp_expr() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_comp_expr() {}
	// $ANTLR start "comp_expr"
	// bek.g:198:1: comp_expr returns [expr result] : (lhs= ID inId= 'in' rhs= str_const |exp1= or_term op= INFIX_ARITHM_OP exp2= or_term |exp= or_term );
	[GrammarRule("comp_expr")]
	private expr comp_expr()
	{
		EnterRule_comp_expr();
		EnterRule("comp_expr", 21);
		TraceIn("comp_expr", 21);
	    expr result = default(expr);

	    int comp_expr_StartIndex = input.Index;

	    IToken lhs = default(IToken);
	    IToken inId = default(IToken);
	    IToken op = default(IToken);
	    strconst rhs = default(strconst);
	    expr exp1 = default(expr);
	    expr exp2 = default(expr);
	    expr exp = default(expr);

		try { DebugEnterRule(GrammarFileName, "comp_expr");
		DebugLocation(198, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 21)) { return result; }

			// bek.g:199:2: (lhs= ID inId= 'in' rhs= str_const |exp1= or_term op= INFIX_ARITHM_OP exp2= or_term |exp= or_term )
			int alt22=3;
			try { DebugEnterDecision(22, decisionCanBacktrack[22]);
			switch (input.LA(1))
			{
			case ID:
				{
				int LA22_2 = input.LA(2);

				if ((EvaluatePredicate(synpred24_bek_fragment)))
				{
					alt22 = 1;
				}
				else if ((EvaluatePredicate(synpred25_bek_fragment)))
				{
					alt22 = 2;
				}
				else if ((true))
				{
					alt22 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 22, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case UNARY_OP:
				{
				int LA22_2 = input.LA(2);

				if ((EvaluatePredicate(synpred25_bek_fragment)))
				{
					alt22 = 2;
				}
				else if ((true))
				{
					alt22 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 22, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 45:
				{
				int LA22_2 = input.LA(2);

				if ((EvaluatePredicate(synpred25_bek_fragment)))
				{
					alt22 = 2;
				}
				else if ((true))
				{
					alt22 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 22, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 35:
				{
				int LA22_2 = input.LA(2);

				if ((EvaluatePredicate(synpred25_bek_fragment)))
				{
					alt22 = 2;
				}
				else if ((true))
				{
					alt22 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 22, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case CHAR:
				{
				int LA22_2 = input.LA(2);

				if ((EvaluatePredicate(synpred25_bek_fragment)))
				{
					alt22 = 2;
				}
				else if ((true))
				{
					alt22 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 22, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case INT:
				{
				int LA22_2 = input.LA(2);

				if ((EvaluatePredicate(synpred25_bek_fragment)))
				{
					alt22 = 2;
				}
				else if ((true))
				{
					alt22 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 22, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case STRING:
				{
				int LA22_2 = input.LA(2);

				if ((EvaluatePredicate(synpred25_bek_fragment)))
				{
					alt22 = 2;
				}
				else if ((true))
				{
					alt22 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 22, 7, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case LSTRING:
				{
				int LA22_2 = input.LA(2);

				if ((EvaluatePredicate(synpred25_bek_fragment)))
				{
					alt22 = 2;
				}
				else if ((true))
				{
					alt22 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 22, 8, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 30:
				{
				int LA22_2 = input.LA(2);

				if ((EvaluatePredicate(synpred25_bek_fragment)))
				{
					alt22 = 2;
				}
				else if ((true))
				{
					alt22 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 22, 9, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 20:
				{
				int LA22_2 = input.LA(2);

				if ((EvaluatePredicate(synpred25_bek_fragment)))
				{
					alt22 = 2;
				}
				else if ((true))
				{
					alt22 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 22, 10, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 22, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// bek.g:199:4: lhs= ID inId= 'in' rhs= str_const
				{
				DebugLocation(199, 7);
				lhs=(IToken)Match(input,ID,Follow._ID_in_comp_expr1125); if (state.failed) return result;
				DebugLocation(199, 15);
				inId=(IToken)Match(input,38,Follow._38_in_comp_expr1129); if (state.failed) return result;
				DebugLocation(199, 24);
				PushFollow(Follow._str_const_in_comp_expr1133);
				rhs=str_const();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(199, 36);
				if (state.backtracking == 0)
				{
					result = new functioncall(new ident(inId.Text, inId.Line, inId.CharPositionInLine), 
					                                                                  new ident(lhs.Text, lhs.Line, lhs.CharPositionInLine), rhs); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// bek.g:201:4: exp1= or_term op= INFIX_ARITHM_OP exp2= or_term
				{
				DebugLocation(201, 8);
				PushFollow(Follow._or_term_in_comp_expr1143);
				exp1=or_term();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(201, 19);
				op=(IToken)Match(input,INFIX_ARITHM_OP,Follow._INFIX_ARITHM_OP_in_comp_expr1147); if (state.failed) return result;
				DebugLocation(201, 40);
				PushFollow(Follow._or_term_in_comp_expr1151);
				exp2=or_term();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(202, 7);
				if (state.backtracking == 0)
				{
					result = new functioncall(new ident(op.Text, op.Line, op.CharPositionInLine), exp1, exp2); 
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// bek.g:203:4: exp= or_term
				{
				DebugLocation(203, 7);
				PushFollow(Follow._or_term_in_comp_expr1167);
				exp=or_term();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(203, 16);
				if (state.backtracking == 0)
				{
					 result = exp; 
				}

				}
				break;

			}
		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("comp_expr", 21);
			LeaveRule("comp_expr", 21);
			LeaveRule_comp_expr();
	        if (state.backtracking > 0) { Memoize(input, 21, comp_expr_StartIndex); }

	    }
	 	DebugLocation(204, 1);
		} finally { DebugExitRule(GrammarFileName, "comp_expr"); }
		return result;

	}
	// $ANTLR end "comp_expr"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_or_term() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_or_term() {}
	// $ANTLR start "or_term"
	// bek.g:206:1: or_term returns [expr result] : exp1= and_term (op= '||' nexp= and_term )* ;
	[GrammarRule("or_term")]
	private expr or_term()
	{
		EnterRule_or_term();
		EnterRule("or_term", 22);
		TraceIn("or_term", 22);
	    expr result = default(expr);

	    int or_term_StartIndex = input.Index;

	    IToken op = default(IToken);
	    expr exp1 = default(expr);
	    expr nexp = default(expr);

		try { DebugEnterRule(GrammarFileName, "or_term");
		DebugLocation(206, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 22)) { return result; }

			// bek.g:207:5: (exp1= and_term (op= '||' nexp= and_term )* )
			DebugEnterAlt(1);
			// bek.g:207:7: exp1= and_term (op= '||' nexp= and_term )*
			{
			DebugLocation(207, 11);
			PushFollow(Follow._and_term_in_or_term1191);
			exp1=and_term();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(207, 21);
			if (state.backtracking == 0)
			{
				 result = exp1; 
			}
			DebugLocation(208, 4);
			// bek.g:208:4: (op= '||' nexp= and_term )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, decisionCanBacktrack[23]);
				int LA23_1 = input.LA(1);

				if ((LA23_1==48))
				{
					alt23 = 1;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// bek.g:208:5: op= '||' nexp= and_term
					{
					DebugLocation(208, 7);
					op=(IToken)Match(input,48,Follow._48_in_or_term1201); if (state.failed) return result;
					DebugLocation(208, 17);
					PushFollow(Follow._and_term_in_or_term1205);
					nexp=and_term();
					PopFollow();
					if (state.failed) return result;
					DebugLocation(208, 27);
					if (state.backtracking == 0)
					{
						 result = new functioncall(new ident(op.Text, op.Line, op.CharPositionInLine), result, nexp); 
					}

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }


			}

		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("or_term", 22);
			LeaveRule("or_term", 22);
			LeaveRule_or_term();
	        if (state.backtracking > 0) { Memoize(input, 22, or_term_StartIndex); }

	    }
	 	DebugLocation(209, 1);
		} finally { DebugExitRule(GrammarFileName, "or_term"); }
		return result;

	}
	// $ANTLR end "or_term"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_and_term() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_and_term() {}
	// $ANTLR start "and_term"
	// bek.g:211:1: and_term returns [expr result] : exp1= sum_term (op= '&&' nexp= sum_term )* ;
	[GrammarRule("and_term")]
	private expr and_term()
	{
		EnterRule_and_term();
		EnterRule("and_term", 23);
		TraceIn("and_term", 23);
	    expr result = default(expr);

	    int and_term_StartIndex = input.Index;

	    IToken op = default(IToken);
	    expr exp1 = default(expr);
	    expr nexp = default(expr);

		try { DebugEnterRule(GrammarFileName, "and_term");
		DebugLocation(211, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 23)) { return result; }

			// bek.g:212:5: (exp1= sum_term (op= '&&' nexp= sum_term )* )
			DebugEnterAlt(1);
			// bek.g:212:7: exp1= sum_term (op= '&&' nexp= sum_term )*
			{
			DebugLocation(212, 11);
			PushFollow(Follow._sum_term_in_and_term1230);
			exp1=sum_term();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(212, 21);
			if (state.backtracking == 0)
			{
				 result = exp1; 
			}
			DebugLocation(213, 4);
			// bek.g:213:4: (op= '&&' nexp= sum_term )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, decisionCanBacktrack[24]);
				int LA24_1 = input.LA(1);

				if ((LA24_1==19))
				{
					alt24 = 1;
				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// bek.g:213:5: op= '&&' nexp= sum_term
					{
					DebugLocation(213, 7);
					op=(IToken)Match(input,19,Follow._19_in_and_term1240); if (state.failed) return result;
					DebugLocation(213, 17);
					PushFollow(Follow._sum_term_in_and_term1244);
					nexp=sum_term();
					PopFollow();
					if (state.failed) return result;
					DebugLocation(213, 27);
					if (state.backtracking == 0)
					{
						 result = new functioncall(new ident(op.Text, op.Line, op.CharPositionInLine), result, nexp); 
					}

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }


			}

		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("and_term", 23);
			LeaveRule("and_term", 23);
			LeaveRule_and_term();
	        if (state.backtracking > 0) { Memoize(input, 23, and_term_StartIndex); }

	    }
	 	DebugLocation(214, 1);
		} finally { DebugExitRule(GrammarFileName, "and_term"); }
		return result;

	}
	// $ANTLR end "and_term"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_sum_term() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_sum_term() {}
	// $ANTLR start "sum_term"
	// bek.g:216:1: sum_term returns [expr result] : exp1= mul_term (op= '+' nexp= mul_term )* ;
	[GrammarRule("sum_term")]
	private expr sum_term()
	{
		EnterRule_sum_term();
		EnterRule("sum_term", 24);
		TraceIn("sum_term", 24);
	    expr result = default(expr);

	    int sum_term_StartIndex = input.Index;

	    IToken op = default(IToken);
	    expr exp1 = default(expr);
	    expr nexp = default(expr);

		try { DebugEnterRule(GrammarFileName, "sum_term");
		DebugLocation(216, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 24)) { return result; }

			// bek.g:217:5: (exp1= mul_term (op= '+' nexp= mul_term )* )
			DebugEnterAlt(1);
			// bek.g:217:7: exp1= mul_term (op= '+' nexp= mul_term )*
			{
			DebugLocation(217, 11);
			PushFollow(Follow._mul_term_in_sum_term1269);
			exp1=mul_term();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(217, 21);
			if (state.backtracking == 0)
			{
				 result = exp1; 
			}
			DebugLocation(218, 4);
			// bek.g:218:4: (op= '+' nexp= mul_term )*
			try { DebugEnterSubRule(25);
			while (true)
			{
				int alt25=2;
				try { DebugEnterDecision(25, decisionCanBacktrack[25]);
				int LA25_1 = input.LA(1);

				if ((LA25_1==23))
				{
					alt25 = 1;
				}


				} finally { DebugExitDecision(25); }
				switch ( alt25 )
				{
				case 1:
					DebugEnterAlt(1);
					// bek.g:218:5: op= '+' nexp= mul_term
					{
					DebugLocation(218, 7);
					op=(IToken)Match(input,23,Follow._23_in_sum_term1279); if (state.failed) return result;
					DebugLocation(218, 16);
					PushFollow(Follow._mul_term_in_sum_term1283);
					nexp=mul_term();
					PopFollow();
					if (state.failed) return result;
					DebugLocation(218, 26);
					if (state.backtracking == 0)
					{
						 result = new functioncall(new ident(op.Text, op.Line, op.CharPositionInLine), result, nexp); 
					}

					}
					break;

				default:
					goto loop25;
				}
			}

			loop25:
				;

			} finally { DebugExitSubRule(25); }


			}

		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("sum_term", 24);
			LeaveRule("sum_term", 24);
			LeaveRule_sum_term();
	        if (state.backtracking > 0) { Memoize(input, 24, sum_term_StartIndex); }

	    }
	 	DebugLocation(219, 1);
		} finally { DebugExitRule(GrammarFileName, "sum_term"); }
		return result;

	}
	// $ANTLR end "sum_term"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_mul_term() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_mul_term() {}
	// $ANTLR start "mul_term"
	// bek.g:221:1: mul_term returns [expr result] : exp1= expr_factor (op= '*' nexp= expr_factor )* ;
	[GrammarRule("mul_term")]
	private expr mul_term()
	{
		EnterRule_mul_term();
		EnterRule("mul_term", 25);
		TraceIn("mul_term", 25);
	    expr result = default(expr);

	    int mul_term_StartIndex = input.Index;

	    IToken op = default(IToken);
	    expr exp1 = default(expr);
	    expr nexp = default(expr);

		try { DebugEnterRule(GrammarFileName, "mul_term");
		DebugLocation(221, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 25)) { return result; }

			// bek.g:222:5: (exp1= expr_factor (op= '*' nexp= expr_factor )* )
			DebugEnterAlt(1);
			// bek.g:222:7: exp1= expr_factor (op= '*' nexp= expr_factor )*
			{
			DebugLocation(222, 11);
			PushFollow(Follow._expr_factor_in_mul_term1308);
			exp1=expr_factor();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(222, 24);
			if (state.backtracking == 0)
			{
				 result = exp1; 
			}
			DebugLocation(223, 4);
			// bek.g:223:4: (op= '*' nexp= expr_factor )*
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=2;
				try { DebugEnterDecision(26, decisionCanBacktrack[26]);
				int LA26_1 = input.LA(1);

				if ((LA26_1==22))
				{
					alt26 = 1;
				}


				} finally { DebugExitDecision(26); }
				switch ( alt26 )
				{
				case 1:
					DebugEnterAlt(1);
					// bek.g:223:5: op= '*' nexp= expr_factor
					{
					DebugLocation(223, 7);
					op=(IToken)Match(input,22,Follow._22_in_mul_term1318); if (state.failed) return result;
					DebugLocation(223, 16);
					PushFollow(Follow._expr_factor_in_mul_term1322);
					nexp=expr_factor();
					PopFollow();
					if (state.failed) return result;
					DebugLocation(223, 29);
					if (state.backtracking == 0)
					{
						 result = new functioncall(new ident(op.Text, op.Line, op.CharPositionInLine), result, nexp); 
					}

					}
					break;

				default:
					goto loop26;
				}
			}

			loop26:
				;

			} finally { DebugExitSubRule(26); }


			}

		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("mul_term", 25);
			LeaveRule("mul_term", 25);
			LeaveRule_mul_term();
	        if (state.backtracking > 0) { Memoize(input, 25, mul_term_StartIndex); }

	    }
	 	DebugLocation(224, 1);
		} finally { DebugExitRule(GrammarFileName, "mul_term"); }
		return result;

	}
	// $ANTLR end "mul_term"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_expr_factor() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_expr_factor() {}
	// $ANTLR start "expr_factor"
	// bek.g:226:1: expr_factor returns [expr result] : (op= UNARY_OP exp1= expr_atom | expr_atom );
	[GrammarRule("expr_factor")]
	private expr expr_factor()
	{
		EnterRule_expr_factor();
		EnterRule("expr_factor", 26);
		TraceIn("expr_factor", 26);
	    expr result = default(expr);

	    int expr_factor_StartIndex = input.Index;

	    IToken op = default(IToken);
	    expr exp1 = default(expr);
	    expr expr_atom12 = default(expr);

		try { DebugEnterRule(GrammarFileName, "expr_factor");
		DebugLocation(226, 3);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 26)) { return result; }

			// bek.g:227:4: (op= UNARY_OP exp1= expr_atom | expr_atom )
			int alt27=2;
			try { DebugEnterDecision(27, decisionCanBacktrack[27]);
			int LA27_1 = input.LA(1);

			if ((LA27_1==UNARY_OP))
			{
				alt27 = 1;
			}
			else if ((LA27_1==CHAR||LA27_1==ID||(LA27_1>=INT && LA27_1<=LSTRING)||LA27_1==STRING||LA27_1==20||LA27_1==30||LA27_1==35||LA27_1==45))
			{
				alt27 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return result;}
				NoViableAltException nvae = new NoViableAltException("", 27, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(27); }
			switch (alt27)
			{
			case 1:
				DebugEnterAlt(1);
				// bek.g:227:6: op= UNARY_OP exp1= expr_atom
				{
				DebugLocation(227, 8);
				op=(IToken)Match(input,UNARY_OP,Follow._UNARY_OP_in_expr_factor1345); if (state.failed) return result;
				DebugLocation(227, 22);
				PushFollow(Follow._expr_atom_in_expr_factor1349);
				exp1=expr_atom();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(227, 33);
				if (state.backtracking == 0)
				{
					 result = new functioncall(new ident(op.Text, op.Line, op.CharPositionInLine), exp1); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// bek.g:228:6: expr_atom
				{
				DebugLocation(228, 6);
				PushFollow(Follow._expr_atom_in_expr_factor1358);
				expr_atom12=expr_atom();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(228, 16);
				if (state.backtracking == 0)
				{
					 result = expr_atom12; 
				}

				}
				break;

			}
		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("expr_factor", 26);
			LeaveRule("expr_factor", 26);
			LeaveRule_expr_factor();
	        if (state.backtracking > 0) { Memoize(input, 26, expr_factor_StartIndex); }

	    }
	 	DebugLocation(229, 3);
		} finally { DebugExitRule(GrammarFileName, "expr_factor"); }
		return result;

	}
	// $ANTLR end "expr_factor"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_expr_atom() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_expr_atom() {}
	// $ANTLR start "expr_atom"
	// bek.g:231:1: expr_atom returns [expr result] : ( bool_const | char_const | str_const | ID | functionapp | '(' exp= comp_expr ')' );
	[GrammarRule("expr_atom")]
	private expr expr_atom()
	{
		EnterRule_expr_atom();
		EnterRule("expr_atom", 27);
		TraceIn("expr_atom", 27);
	    expr result = default(expr);

	    int expr_atom_StartIndex = input.Index;

	    IToken ID16 = default(IToken);
	    expr exp = default(expr);
	    boolconst bool_const13 = default(boolconst);
	    charconst char_const14 = default(charconst);
	    strconst str_const15 = default(strconst);
	    functioncall functionapp17 = default(functioncall);

		try { DebugEnterRule(GrammarFileName, "expr_atom");
		DebugLocation(231, 3);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 27)) { return result; }

			// bek.g:232:4: ( bool_const | char_const | str_const | ID | functionapp | '(' exp= comp_expr ')' )
			int alt28=6;
			try { DebugEnterDecision(28, decisionCanBacktrack[28]);
			switch (input.LA(1))
			{
			case 35:
			case 45:
				{
				alt28 = 1;
				}
				break;
			case CHAR:
			case INT:
				{
				alt28 = 2;
				}
				break;
			case LSTRING:
			case STRING:
				{
				alt28 = 3;
				}
				break;
			case ID:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==20))
				{
					alt28 = 5;
				}
				else if ((LA28_2==EOF||LA28_2==INFIX_ARITHM_OP||LA28_2==19||(LA28_2>=21 && LA28_2<=24)||LA28_2==27||LA28_2==31||LA28_2==48))
				{
					alt28 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 28, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 30:
				{
				alt28 = 5;
				}
				break;
			case 20:
				{
				alt28 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 28, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// bek.g:232:6: bool_const
				{
				DebugLocation(232, 6);
				PushFollow(Follow._bool_const_in_expr_atom1379);
				bool_const13=bool_const();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(232, 17);
				if (state.backtracking == 0)
				{
					 result = bool_const13; 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// bek.g:233:6: char_const
				{
				DebugLocation(233, 6);
				PushFollow(Follow._char_const_in_expr_atom1388);
				char_const14=char_const();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(233, 17);
				if (state.backtracking == 0)
				{
					 result = char_const14; 
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// bek.g:234:6: str_const
				{
				DebugLocation(234, 6);
				PushFollow(Follow._str_const_in_expr_atom1397);
				str_const15=str_const();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(234, 17);
				if (state.backtracking == 0)
				{
					 result = str_const15;  
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// bek.g:235:6: ID
				{
				DebugLocation(235, 6);
				ID16=(IToken)Match(input,ID,Follow._ID_in_expr_atom1407); if (state.failed) return result;
				DebugLocation(235, 17);
				if (state.backtracking == 0)
				{
					 result = new ident(ID16.Text, ID16.Line, ID16.CharPositionInLine); 
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// bek.g:236:6: functionapp
				{
				DebugLocation(236, 6);
				PushFollow(Follow._functionapp_in_expr_atom1424);
				functionapp17=functionapp();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(236, 20);
				if (state.backtracking == 0)
				{
					 result = functionapp17; 
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// bek.g:237:6: '(' exp= comp_expr ')'
				{
				DebugLocation(237, 6);
				Match(input,20,Follow._20_in_expr_atom1435); if (state.failed) return result;
				DebugLocation(237, 13);
				PushFollow(Follow._comp_expr_in_expr_atom1439);
				exp=comp_expr();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(237, 24);
				Match(input,21,Follow._21_in_expr_atom1441); if (state.failed) return result;
				DebugLocation(237, 28);
				if (state.backtracking == 0)
				{
					 result = exp; 
				}

				}
				break;

			}
		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("expr_atom", 27);
			LeaveRule("expr_atom", 27);
			LeaveRule_expr_atom();
	        if (state.backtracking > 0) { Memoize(input, 27, expr_atom_StartIndex); }

	    }
	 	DebugLocation(238, 3);
		} finally { DebugExitRule(GrammarFileName, "expr_atom"); }
		return result;

	}
	// $ANTLR end "expr_atom"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_bool_const() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_bool_const() {}
	// $ANTLR start "bool_const"
	// bek.g:240:1: bool_const returns [boolconst result] : (t= 'true' |f= 'false' );
	[GrammarRule("bool_const")]
	private boolconst bool_const()
	{
		EnterRule_bool_const();
		EnterRule("bool_const", 28);
		TraceIn("bool_const", 28);
	    boolconst result = default(boolconst);

	    int bool_const_StartIndex = input.Index;

	    IToken t = default(IToken);
	    IToken f = default(IToken);

		try { DebugEnterRule(GrammarFileName, "bool_const");
		DebugLocation(240, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 28)) { return result; }

			// bek.g:241:2: (t= 'true' |f= 'false' )
			int alt29=2;
			try { DebugEnterDecision(29, decisionCanBacktrack[29]);
			int LA29_1 = input.LA(1);

			if ((LA29_1==45))
			{
				alt29 = 1;
			}
			else if ((LA29_1==35))
			{
				alt29 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return result;}
				NoViableAltException nvae = new NoViableAltException("", 29, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(29); }
			switch (alt29)
			{
			case 1:
				DebugEnterAlt(1);
				// bek.g:241:4: t= 'true'
				{
				DebugLocation(241, 5);
				t=(IToken)Match(input,45,Follow._45_in_bool_const1462); if (state.failed) return result;
				DebugLocation(241, 13);
				if (state.backtracking == 0)
				{
					result = new boolconst(t.Line, t.CharPositionInLine, true);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// bek.g:242:4: f= 'false'
				{
				DebugLocation(242, 5);
				f=(IToken)Match(input,35,Follow._35_in_bool_const1471); if (state.failed) return result;
				DebugLocation(242, 13);
				if (state.backtracking == 0)
				{
					result = new boolconst(f.Line, f.CharPositionInLine, false);
				}

				}
				break;

			}
		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("bool_const", 28);
			LeaveRule("bool_const", 28);
			LeaveRule_bool_const();
	        if (state.backtracking > 0) { Memoize(input, 28, bool_const_StartIndex); }

	    }
	 	DebugLocation(243, 1);
		} finally { DebugExitRule(GrammarFileName, "bool_const"); }
		return result;

	}
	// $ANTLR end "bool_const"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_char_const() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_char_const() {}
	// $ANTLR start "char_const"
	// bek.g:245:1: char_const returns [charconst result] : ( CHAR | INT );
	[GrammarRule("char_const")]
	private charconst char_const()
	{
		EnterRule_char_const();
		EnterRule("char_const", 29);
		TraceIn("char_const", 29);
	    charconst result = default(charconst);

	    int char_const_StartIndex = input.Index;

	    IToken CHAR18 = default(IToken);
	    IToken INT19 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "char_const");
		DebugLocation(245, 3);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 29)) { return result; }

			// bek.g:246:4: ( CHAR | INT )
			int alt30=2;
			try { DebugEnterDecision(30, decisionCanBacktrack[30]);
			int LA30_1 = input.LA(1);

			if ((LA30_1==CHAR))
			{
				alt30 = 1;
			}
			else if ((LA30_1==INT))
			{
				alt30 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return result;}
				NoViableAltException nvae = new NoViableAltException("", 30, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(30); }
			switch (alt30)
			{
			case 1:
				DebugEnterAlt(1);
				// bek.g:246:6: CHAR
				{
				DebugLocation(246, 6);
				CHAR18=(IToken)Match(input,CHAR,Follow._CHAR_in_char_const1494); if (state.failed) return result;
				DebugLocation(246, 11);
				if (state.backtracking == 0)
				{
					 result = new charconst(CHAR18.Line, CHAR18.CharPositionInLine, CHAR18.Text); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// bek.g:247:6: INT
				{
				DebugLocation(247, 6);
				INT19=(IToken)Match(input,INT,Follow._INT_in_char_const1503); if (state.failed) return result;
				DebugLocation(247, 10);
				if (state.backtracking == 0)
				{
					 result = new charconst(INT19.Line, INT19.CharPositionInLine, INT19.Text); 
				}

				}
				break;

			}
		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("char_const", 29);
			LeaveRule("char_const", 29);
			LeaveRule_char_const();
	        if (state.backtracking > 0) { Memoize(input, 29, char_const_StartIndex); }

	    }
	 	DebugLocation(248, 3);
		} finally { DebugExitRule(GrammarFileName, "char_const"); }
		return result;

	}
	// $ANTLR end "char_const"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_str_const() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_str_const() {}
	// $ANTLR start "str_const"
	// bek.g:250:1: str_const returns [strconst result] : ( STRING | LSTRING );
	[GrammarRule("str_const")]
	private strconst str_const()
	{
		EnterRule_str_const();
		EnterRule("str_const", 30);
		TraceIn("str_const", 30);
	    strconst result = default(strconst);

	    int str_const_StartIndex = input.Index;

	    IToken STRING20 = default(IToken);
	    IToken LSTRING21 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "str_const");
		DebugLocation(250, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 30)) { return result; }

			// bek.g:251:2: ( STRING | LSTRING )
			int alt31=2;
			try { DebugEnterDecision(31, decisionCanBacktrack[31]);
			int LA31_1 = input.LA(1);

			if ((LA31_1==STRING))
			{
				alt31 = 1;
			}
			else if ((LA31_1==LSTRING))
			{
				alt31 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return result;}
				NoViableAltException nvae = new NoViableAltException("", 31, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(31); }
			switch (alt31)
			{
			case 1:
				DebugEnterAlt(1);
				// bek.g:251:4: STRING
				{
				DebugLocation(251, 4);
				STRING20=(IToken)Match(input,STRING,Follow._STRING_in_str_const1525); if (state.failed) return result;
				DebugLocation(251, 11);
				if (state.backtracking == 0)
				{
					result =  new strconst(STRING20.Line, STRING20.CharPositionInLine, STRING20.Text);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// bek.g:252:7: LSTRING
				{
				DebugLocation(252, 7);
				LSTRING21=(IToken)Match(input,LSTRING,Follow._LSTRING_in_str_const1535); if (state.failed) return result;
				DebugLocation(252, 15);
				if (state.backtracking == 0)
				{
					result =  new strconst(LSTRING21.Line, LSTRING21.CharPositionInLine, LSTRING21.Text);
				}

				}
				break;

			}
		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("str_const", 30);
			LeaveRule("str_const", 30);
			LeaveRule_str_const();
	        if (state.backtracking > 0) { Memoize(input, 30, str_const_StartIndex); }

	    }
	 	DebugLocation(253, 1);
		} finally { DebugExitRule(GrammarFileName, "str_const"); }
		return result;

	}
	// $ANTLR end "str_const"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_functionapp() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_functionapp() {}
	// $ANTLR start "functionapp"
	// bek.g:255:1: functionapp returns [functioncall result] : (fname= ID '(' param= exp_param_list ')' |str= '[' param= exp_param_list ']' );
	[GrammarRule("functionapp")]
	private functioncall functionapp()
	{
		EnterRule_functionapp();
		EnterRule("functionapp", 31);
		TraceIn("functionapp", 31);
	    functioncall result = default(functioncall);

	    int functionapp_StartIndex = input.Index;

	    IToken fname = default(IToken);
	    IToken str = default(IToken);
	    List<expr> param = default(List<expr>);

		try { DebugEnterRule(GrammarFileName, "functionapp");
		DebugLocation(255, 3);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 31)) { return result; }

			// bek.g:256:4: (fname= ID '(' param= exp_param_list ')' |str= '[' param= exp_param_list ']' )
			int alt32=2;
			try { DebugEnterDecision(32, decisionCanBacktrack[32]);
			int LA32_1 = input.LA(1);

			if ((LA32_1==ID))
			{
				alt32 = 1;
			}
			else if ((LA32_1==30))
			{
				alt32 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return result;}
				NoViableAltException nvae = new NoViableAltException("", 32, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(32); }
			switch (alt32)
			{
			case 1:
				DebugEnterAlt(1);
				// bek.g:256:6: fname= ID '(' param= exp_param_list ')'
				{
				DebugLocation(256, 11);
				fname=(IToken)Match(input,ID,Follow._ID_in_functionapp1557); if (state.failed) return result;
				DebugLocation(256, 15);
				Match(input,20,Follow._20_in_functionapp1559); if (state.failed) return result;
				DebugLocation(256, 24);
				PushFollow(Follow._exp_param_list_in_functionapp1563);
				param=exp_param_list();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(256, 40);
				Match(input,21,Follow._21_in_functionapp1565); if (state.failed) return result;
				DebugLocation(256, 44);
				if (state.backtracking == 0)
				{
					 result = new functioncall(new ident(fname.Text, fname.Line, fname.CharPositionInLine), param); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// bek.g:257:6: str= '[' param= exp_param_list ']'
				{
				DebugLocation(257, 9);
				str=(IToken)Match(input,30,Follow._30_in_functionapp1577); if (state.failed) return result;
				DebugLocation(257, 19);
				PushFollow(Follow._exp_param_list_in_functionapp1581);
				param=exp_param_list();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(257, 35);
				Match(input,31,Follow._31_in_functionapp1583); if (state.failed) return result;
				DebugLocation(257, 39);
				if (state.backtracking == 0)
				{
					 result = new functioncall(new ident("string", str.Line, str.CharPositionInLine), param); 
				}

				}
				break;

			}
		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("functionapp", 31);
			LeaveRule("functionapp", 31);
			LeaveRule_functionapp();
	        if (state.backtracking > 0) { Memoize(input, 31, functionapp_StartIndex); }

	    }
	 	DebugLocation(258, 3);
		} finally { DebugExitRule(GrammarFileName, "functionapp"); }
		return result;

	}
	// $ANTLR end "functionapp"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_exp_param_list() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_exp_param_list() {}
	// $ANTLR start "exp_param_list"
	// bek.g:260:1: exp_param_list returns [ List<expr> result ] : (|exp= comp_expr ( ',' nexp= comp_expr )* );
	[GrammarRule("exp_param_list")]
	private List<expr> exp_param_list()
	{
		EnterRule_exp_param_list();
		EnterRule("exp_param_list", 32);
		TraceIn("exp_param_list", 32);
	    List<expr> result = default(List<expr>);

	    int exp_param_list_StartIndex = input.Index;

	    expr exp = default(expr);
	    expr nexp = default(expr);

	     result = new List<expr>(); 
		try { DebugEnterRule(GrammarFileName, "exp_param_list");
		DebugLocation(260, 3);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 32)) { return result; }

			// bek.g:261:4: (|exp= comp_expr ( ',' nexp= comp_expr )* )
			int alt34=2;
			try { DebugEnterDecision(34, decisionCanBacktrack[34]);
			int LA34_1 = input.LA(1);

			if ((LA34_1==21||LA34_1==31))
			{
				alt34 = 1;
			}
			else if ((LA34_1==CHAR||LA34_1==ID||(LA34_1>=INT && LA34_1<=LSTRING)||(LA34_1>=STRING && LA34_1<=UNARY_OP)||LA34_1==20||LA34_1==30||LA34_1==35||LA34_1==45))
			{
				alt34 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return result;}
				NoViableAltException nvae = new NoViableAltException("", 34, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(34); }
			switch (alt34)
			{
			case 1:
				DebugEnterAlt(1);
				// bek.g:262:4: 
				{
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// bek.g:262:6: exp= comp_expr ( ',' nexp= comp_expr )*
				{
				DebugLocation(262, 9);
				PushFollow(Follow._comp_expr_in_exp_param_list1619);
				exp=comp_expr();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(262, 20);
				if (state.backtracking == 0)
				{
					 result.Add(exp); 
				}
				DebugLocation(263, 6);
				// bek.g:263:6: ( ',' nexp= comp_expr )*
				try { DebugEnterSubRule(33);
				while (true)
				{
					int alt33=2;
					try { DebugEnterDecision(33, decisionCanBacktrack[33]);
					int LA33_1 = input.LA(1);

					if ((LA33_1==24))
					{
						alt33 = 1;
					}


					} finally { DebugExitDecision(33); }
					switch ( alt33 )
					{
					case 1:
						DebugEnterAlt(1);
						// bek.g:263:7: ',' nexp= comp_expr
						{
						DebugLocation(263, 7);
						Match(input,24,Follow._24_in_exp_param_list1629); if (state.failed) return result;
						DebugLocation(263, 15);
						PushFollow(Follow._comp_expr_in_exp_param_list1633);
						nexp=comp_expr();
						PopFollow();
						if (state.failed) return result;
						DebugLocation(263, 26);
						if (state.backtracking == 0)
						{
							 result.Add(nexp); 
						}

						}
						break;

					default:
						goto loop33;
					}
				}

				loop33:
					;

				} finally { DebugExitSubRule(33); }


				}
				break;

			}
		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("exp_param_list", 32);
			LeaveRule("exp_param_list", 32);
			LeaveRule_exp_param_list();
	        if (state.backtracking > 0) { Memoize(input, 32, exp_param_list_StartIndex); }

	    }
	 	DebugLocation(264, 3);
		} finally { DebugExitRule(GrammarFileName, "exp_param_list"); }
		return result;

	}
	// $ANTLR end "exp_param_list"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_toEof() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_toEof() {}
	// $ANTLR start "toEof"
	// bek.g:299:1: toEof : ( . )* EOF ;
	[GrammarRule("toEof")]
	private void toEof()
	{
		EnterRule_toEof();
		EnterRule("toEof", 33);
		TraceIn("toEof", 33);
	    int toEof_StartIndex = input.Index;

		try { DebugEnterRule(GrammarFileName, "toEof");
		DebugLocation(299, 14);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 33)) { return; }

			// bek.g:299:7: ( ( . )* EOF )
			DebugEnterAlt(1);
			// bek.g:299:9: ( . )* EOF
			{
			DebugLocation(299, 9);
			// bek.g:299:9: ( . )*
			try { DebugEnterSubRule(35);
			while (true)
			{
				int alt35=2;
				try { DebugEnterDecision(35, decisionCanBacktrack[35]);
				int LA35_1 = input.LA(1);

				if (((LA35_1>=BIG_UNICODE_ESC && LA35_1<=49)))
				{
					alt35 = 1;
				}


				} finally { DebugExitDecision(35); }
				switch ( alt35 )
				{
				case 1:
					DebugEnterAlt(1);
					// bek.g:299:9: .
					{
					DebugLocation(299, 9);
					MatchAny(input); if (state.failed) return;

					}
					break;

				default:
					goto loop35;
				}
			}

			loop35:
				;

			} finally { DebugExitSubRule(35); }

			DebugLocation(299, 12);
			Match(input,EOF,Follow._EOF_in_toEof1922); if (state.failed) return;

			}

		}

		catch (RecognitionException e) {
		  throw e;
		}
		finally
		{
			TraceOut("toEof", 33);
			LeaveRule("toEof", 33);
			LeaveRule_toEof();
	        if (state.backtracking > 0) { Memoize(input, 33, toEof_StartIndex); }

	    }
	 	DebugLocation(299, 14);
		} finally { DebugExitRule(GrammarFileName, "toEof"); }
		return;

	}
	// $ANTLR end "toEof"
	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_synpred10_bek_fragment() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_synpred10_bek_fragment() {}

	// $ANTLR start synpred10_bek
	public void synpred10_bek_fragment()
	{
		iterexpr cases = default(iterexpr);
		List<itercase> endcases = default(List<itercase>);

		EnterRule_synpred10_bek_fragment();
		EnterRule("synpred10_bek_fragment", 43);
		TraceIn("synpred10_bek_fragment", 43);
		try
		{
			// bek.g:107:4: (cases= iter_expr_main 'end' '{' endcases= case_list '}' )
			DebugEnterAlt(1);
			// bek.g:107:4: cases= iter_expr_main 'end' '{' endcases= case_list '}'
			{
			DebugLocation(107, 9);
			PushFollow(Follow._iter_expr_main_in_synpred10_bek489);
			cases=iter_expr_main();
			PopFollow();
			if (state.failed) return;
			DebugLocation(107, 25);
			Match(input,34,Follow._34_in_synpred10_bek491); if (state.failed) return;
			DebugLocation(107, 31);
			Match(input,47,Follow._47_in_synpred10_bek493); if (state.failed) return;
			DebugLocation(107, 43);
			PushFollow(Follow._case_list_in_synpred10_bek497);
			endcases=case_list();
			PopFollow();
			if (state.failed) return;
			DebugLocation(107, 54);
			Match(input,49,Follow._49_in_synpred10_bek499); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred10_bek_fragment", 43);
			LeaveRule("synpred10_bek_fragment", 43);
			LeaveRule_synpred10_bek_fragment();
		}
	}
	// $ANTLR end synpred10_bek
	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_synpred24_bek_fragment() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_synpred24_bek_fragment() {}

	// $ANTLR start synpred24_bek
	public void synpred24_bek_fragment()
	{
		IToken lhs = default(IToken);
		IToken inId = default(IToken);
		strconst rhs = default(strconst);

		EnterRule_synpred24_bek_fragment();
		EnterRule("synpred24_bek_fragment", 57);
		TraceIn("synpred24_bek_fragment", 57);
		try
		{
			// bek.g:199:4: (lhs= ID inId= 'in' rhs= str_const )
			DebugEnterAlt(1);
			// bek.g:199:4: lhs= ID inId= 'in' rhs= str_const
			{
			DebugLocation(199, 7);
			lhs=(IToken)Match(input,ID,Follow._ID_in_synpred24_bek1125); if (state.failed) return;
			DebugLocation(199, 15);
			inId=(IToken)Match(input,38,Follow._38_in_synpred24_bek1129); if (state.failed) return;
			DebugLocation(199, 24);
			PushFollow(Follow._str_const_in_synpred24_bek1133);
			rhs=str_const();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred24_bek_fragment", 57);
			LeaveRule("synpred24_bek_fragment", 57);
			LeaveRule_synpred24_bek_fragment();
		}
	}
	// $ANTLR end synpred24_bek
	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_synpred25_bek_fragment() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_synpred25_bek_fragment() {}

	// $ANTLR start synpred25_bek
	public void synpred25_bek_fragment()
	{
		IToken op = default(IToken);
		expr exp1 = default(expr);
		expr exp2 = default(expr);

		EnterRule_synpred25_bek_fragment();
		EnterRule("synpred25_bek_fragment", 58);
		TraceIn("synpred25_bek_fragment", 58);
		try
		{
			// bek.g:201:4: (exp1= or_term op= INFIX_ARITHM_OP exp2= or_term )
			DebugEnterAlt(1);
			// bek.g:201:4: exp1= or_term op= INFIX_ARITHM_OP exp2= or_term
			{
			DebugLocation(201, 8);
			PushFollow(Follow._or_term_in_synpred25_bek1143);
			exp1=or_term();
			PopFollow();
			if (state.failed) return;
			DebugLocation(201, 19);
			op=(IToken)Match(input,INFIX_ARITHM_OP,Follow._INFIX_ARITHM_OP_in_synpred25_bek1147); if (state.failed) return;
			DebugLocation(201, 40);
			PushFollow(Follow._or_term_in_synpred25_bek1151);
			exp2=or_term();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred25_bek_fragment", 58);
			LeaveRule("synpred25_bek_fragment", 58);
			LeaveRule_synpred25_bek_fragment();
		}
	}
	// $ANTLR end synpred25_bek
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _bekLocalFunctions_in_bekPgms111 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _bekPgm_in_bekPgms118 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_bekPgms131 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _40_in_bekPgm150 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ID_in_bekPgm154 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _20_in_bekPgm156 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ID_in_bekPgm160 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _21_in_bekPgm162 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _47_in_bekPgm164 = new BitSet(new ulong[]{0xC0000000000UL});
		public static readonly BitSet _statement_in_bekPgm168 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_bekPgm170 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _36_in_bekLocalFunctions202 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ID_in_bekLocalFunctions206 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _20_in_bekLocalFunctions208 = new BitSet(new ulong[]{0x200400UL});
		public static readonly BitSet _ident_list_in_bekLocalFunctions212 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _21_in_bekLocalFunctions214 = new BitSet(new ulong[]{0x10000000UL});
		public static readonly BitSet _28_in_bekLocalFunctions216 = new BitSet(new ulong[]{0x20084011B420UL});
		public static readonly BitSet _comp_expr_in_bekLocalFunctions220 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _27_in_bekLocalFunctions222 = new BitSet(new ulong[]{0x1000000002UL});
		public static readonly BitSet _ID_in_ident_list259 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _24_in_ident_list271 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ID_in_ident_list275 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _43_in_statement307 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _iter_expr_in_statement311 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _27_in_statement313 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _42_in_statement331 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _47_in_statement333 = new BitSet(new ulong[]{0xA000UL});
		public static readonly BitSet _replace_cases_in_statement337 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_statement339 = new BitSet(new ulong[]{0x8000002UL});
		public static readonly BitSet _27_in_statement342 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _str_const_in_replace_cases379 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _29_in_replace_cases383 = new BitSet(new ulong[]{0x4000A000UL});
		public static readonly BitSet _replace_rhs_in_replace_cases387 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _27_in_replace_cases389 = new BitSet(new ulong[]{0x20000A002UL});
		public static readonly BitSet _33_in_replace_cases409 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _29_in_replace_cases411 = new BitSet(new ulong[]{0x4000A000UL});
		public static readonly BitSet _replace_rhs_in_replace_cases415 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _27_in_replace_cases417 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _str_const_in_replace_rhs446 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _30_in_replace_rhs457 = new BitSet(new ulong[]{0x2008C011B420UL});
		public static readonly BitSet _exp_param_list_in_replace_rhs461 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _31_in_replace_rhs463 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _iter_expr_main_in_iter_expr489 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_iter_expr491 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _47_in_iter_expr493 = new BitSet(new ulong[]{0x500000000UL});
		public static readonly BitSet _case_list_in_iter_expr497 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_iter_expr499 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _iter_expr_main_in_iter_expr509 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _39_in_iter_expr_main526 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _20_in_iter_expr_main528 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ID_in_iter_expr_main532 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _38_in_iter_expr_main534 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ID_in_iter_expr_main538 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _21_in_iter_expr_main540 = new BitSet(new ulong[]{0x800040000000UL});
		public static readonly BitSet _iter_init_in_iter_expr_main555 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _47_in_iter_expr_main567 = new BitSet(new ulong[]{0x500000000UL});
		public static readonly BitSet _case_list_in_iter_expr_main590 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_iter_expr_main605 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _30_in_iter_init641 = new BitSet(new ulong[]{0x80000400UL});
		public static readonly BitSet _iter_const_assgn_in_iter_init646 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _27_in_iter_init648 = new BitSet(new ulong[]{0x80000400UL});
		public static readonly BitSet _31_in_iter_init654 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_iter_const_assgn672 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _26_in_iter_const_assgn674 = new BitSet(new ulong[]{0x1020UL});
		public static readonly BitSet _char_const_in_iter_const_assgn678 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_iter_const_assgn689 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _26_in_iter_const_assgn691 = new BitSet(new ulong[]{0x200800000000UL});
		public static readonly BitSet _bool_const_in_iter_const_assgn695 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _case_stmt_in_case_list722 = new BitSet(new ulong[]{0x500000002UL});
		public static readonly BitSet _32_in_case_stmt742 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _20_in_case_stmt744 = new BitSet(new ulong[]{0x20084011B420UL});
		public static readonly BitSet _comp_expr_in_case_stmt747 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _21_in_case_stmt749 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _25_in_case_stmt751 = new BitSet(new ulong[]{0x522000000400UL});
		public static readonly BitSet _iterstmt_list_or_ite_in_case_stmt761 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _34_in_case_stmt769 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _32_in_case_stmt771 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _20_in_case_stmt773 = new BitSet(new ulong[]{0x20084011B420UL});
		public static readonly BitSet _comp_expr_in_case_stmt775 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _21_in_case_stmt777 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _25_in_case_stmt779 = new BitSet(new ulong[]{0x522000000400UL});
		public static readonly BitSet _iterstmt_list_or_ite_in_case_stmt789 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifthenelse_pairs_in_iterstmt_list_or_ite813 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _iterstmt_list_in_iterstmt_list_or_ite820 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _37_in_ifthenelse_pairs846 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _20_in_ifthenelse_pairs848 = new BitSet(new ulong[]{0x20084011B420UL});
		public static readonly BitSet _comp_expr_in_ifthenelse_pairs852 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _21_in_ifthenelse_pairs854 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _47_in_ifthenelse_pairs856 = new BitSet(new ulong[]{0x522000000400UL});
		public static readonly BitSet _iterstmt_list_or_ite_in_ifthenelse_pairs860 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_ifthenelse_pairs862 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _33_in_ifthenelse_pairs877 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _37_in_ifthenelse_pairs879 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _20_in_ifthenelse_pairs881 = new BitSet(new ulong[]{0x20084011B420UL});
		public static readonly BitSet _comp_expr_in_ifthenelse_pairs885 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _21_in_ifthenelse_pairs887 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _47_in_ifthenelse_pairs889 = new BitSet(new ulong[]{0x522000000400UL});
		public static readonly BitSet _iterstmt_list_or_ite_in_ifthenelse_pairs893 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_ifthenelse_pairs895 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _33_in_ifthenelse_pairs910 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _47_in_ifthenelse_pairs912 = new BitSet(new ulong[]{0x522000000400UL});
		public static readonly BitSet _iterstmt_list_or_ite_in_ifthenelse_pairs916 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_ifthenelse_pairs918 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _iter_stmt_in_iterstmt_list950 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _27_in_iterstmt_list952 = new BitSet(new ulong[]{0x520000000402UL});
		public static readonly BitSet _44_in_iter_stmt971 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_iter_stmt979 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _26_in_iter_stmt981 = new BitSet(new ulong[]{0x20084011B420UL});
		public static readonly BitSet _comp_expr_in_iter_stmt985 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _yield_stmt_in_iter_stmt992 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _raise_stmt_in_iter_stmt999 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _46_in_yield_stmt1019 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _20_in_yield_stmt1021 = new BitSet(new ulong[]{0x20084011B420UL});
		public static readonly BitSet _yield_expr_list_in_yield_stmt1025 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _21_in_yield_stmt1027 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _46_in_yield_stmt1036 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _20_in_yield_stmt1038 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _21_in_yield_stmt1040 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _41_in_raise_stmt1057 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ID_in_raise_stmt1061 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _comp_expr_in_yield_expr_list1088 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _24_in_yield_expr_list1095 = new BitSet(new ulong[]{0x20084011B420UL});
		public static readonly BitSet _comp_expr_in_yield_expr_list1099 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _ID_in_comp_expr1125 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _38_in_comp_expr1129 = new BitSet(new ulong[]{0xA000UL});
		public static readonly BitSet _str_const_in_comp_expr1133 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _or_term_in_comp_expr1143 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _INFIX_ARITHM_OP_in_comp_expr1147 = new BitSet(new ulong[]{0x20084011B420UL});
		public static readonly BitSet _or_term_in_comp_expr1151 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _or_term_in_comp_expr1167 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _and_term_in_or_term1191 = new BitSet(new ulong[]{0x1000000000002UL});
		public static readonly BitSet _48_in_or_term1201 = new BitSet(new ulong[]{0x20084011B420UL});
		public static readonly BitSet _and_term_in_or_term1205 = new BitSet(new ulong[]{0x1000000000002UL});
		public static readonly BitSet _sum_term_in_and_term1230 = new BitSet(new ulong[]{0x80002UL});
		public static readonly BitSet _19_in_and_term1240 = new BitSet(new ulong[]{0x20084011B420UL});
		public static readonly BitSet _sum_term_in_and_term1244 = new BitSet(new ulong[]{0x80002UL});
		public static readonly BitSet _mul_term_in_sum_term1269 = new BitSet(new ulong[]{0x800002UL});
		public static readonly BitSet _23_in_sum_term1279 = new BitSet(new ulong[]{0x20084011B420UL});
		public static readonly BitSet _mul_term_in_sum_term1283 = new BitSet(new ulong[]{0x800002UL});
		public static readonly BitSet _expr_factor_in_mul_term1308 = new BitSet(new ulong[]{0x400002UL});
		public static readonly BitSet _22_in_mul_term1318 = new BitSet(new ulong[]{0x20084011B420UL});
		public static readonly BitSet _expr_factor_in_mul_term1322 = new BitSet(new ulong[]{0x400002UL});
		public static readonly BitSet _UNARY_OP_in_expr_factor1345 = new BitSet(new ulong[]{0x20084010B420UL});
		public static readonly BitSet _expr_atom_in_expr_factor1349 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_atom_in_expr_factor1358 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bool_const_in_expr_atom1379 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _char_const_in_expr_atom1388 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _str_const_in_expr_atom1397 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_expr_atom1407 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionapp_in_expr_atom1424 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _20_in_expr_atom1435 = new BitSet(new ulong[]{0x20084011B420UL});
		public static readonly BitSet _comp_expr_in_expr_atom1439 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _21_in_expr_atom1441 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _45_in_bool_const1462 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _35_in_bool_const1471 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHAR_in_char_const1494 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_char_const1503 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_str_const1525 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LSTRING_in_str_const1535 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_functionapp1557 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _20_in_functionapp1559 = new BitSet(new ulong[]{0x20084031B420UL});
		public static readonly BitSet _exp_param_list_in_functionapp1563 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _21_in_functionapp1565 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _30_in_functionapp1577 = new BitSet(new ulong[]{0x2008C011B420UL});
		public static readonly BitSet _exp_param_list_in_functionapp1581 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _31_in_functionapp1583 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _comp_expr_in_exp_param_list1619 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _24_in_exp_param_list1629 = new BitSet(new ulong[]{0x20084011B420UL});
		public static readonly BitSet _comp_expr_in_exp_param_list1633 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _EOF_in_toEof1922 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _iter_expr_main_in_synpred10_bek489 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_synpred10_bek491 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _47_in_synpred10_bek493 = new BitSet(new ulong[]{0x500000000UL});
		public static readonly BitSet _case_list_in_synpred10_bek497 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_synpred10_bek499 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred24_bek1125 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _38_in_synpred24_bek1129 = new BitSet(new ulong[]{0xA000UL});
		public static readonly BitSet _str_const_in_synpred24_bek1133 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _or_term_in_synpred25_bek1143 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _INFIX_ARITHM_OP_in_synpred25_bek1147 = new BitSet(new ulong[]{0x20084011B420UL});
		public static readonly BitSet _or_term_in_synpred25_bek1151 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace Microsoft.Bek.Frontend.ParserImpl
